unit pthreads.win;
{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }
{$define __MSVCRT__}
//{$define _WIN64 }
{$define _X86_}
//{$define HAVE_CPU_AFFINITY}
{$define __PTW32_CONFIG_MSVC7}
{$MINENUMSIZE 4}

interface
{$POINTERMATH ON}
uses
 {$IFDEF FPC}
   sysutils, windows,  jwaiptypes, jwawindows,
 {$else}
   Winapi.Windows,
   //JwaWinBase, JwaWinNT, JwaWinError,
   System.Classes, System.SysUtils,
   System.Variants, System.Win.Crtl,
 {$endif}    libc.Types;

const
   _JBFP    = 1;
   _JBMOV   = 60;
   _JBOFF   = 4;
   _NSETJMP = 17;
   __PTW32_EPS_EXIT  =                (1);
   __PTW32_EPS_CANCEL  =              (2);

   CPU_SETSIZE = sizeof(size_t)*8;
   __PTW32_ATTR_VALID = ulong( $C4C0FFEE);
   __PTW32_OBJECT_INVALID   = nil;


  _POSIX_THREADS = 200809;
  _POSIX_READER_WRITER_LOCKS = 200809;
  _POSIX_SPIN_LOCKS = 200809;
  _POSIX_BARRIERS = 200809;
  _POSIX_THREAD_SAFE_FUNCTIONS = 200809;
  {$IFDEF  FPC}
  _POSIX_THREAD_ATTR_STACKSIZE: Int64  = 200809;
  {$ELSE}
  _POSIX_THREAD_ATTR_STACKSIZE = 20080;
  {$ENDIF}
  _POSIX_ROBUST_MUTEXES = 200809;
  _POSIX_THREAD_ATTR_STACKADDR = -1;
  _POSIX_THREAD_PRIO_INHERIT = -1;
  _POSIX_THREAD_PRIO_PROTECT = -1;
  _POSIX_THREAD_PRIORITY_SCHEDULING = -1;
  _POSIX_THREAD_PROCESS_SHARED = -1;
  _POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4;
  PTHREAD_DESTRUCTOR_ITERATIONS = _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
  _POSIX_THREAD_KEYS_MAX = 128;
  PTHREAD_KEYS_MAX = _POSIX_THREAD_KEYS_MAX;
  PTHREAD_STACK_MIN = 0;
  _POSIX_THREAD_THREADS_MAX = 64;
  PTHREAD_THREADS_MAX = 2019;
  _POSIX_SEM_NSEMS_MAX = 256;
  SEM_NSEMS_MAX = 1024;
  _POSIX_SEM_VALUE_MAX = 32767;
  { Minimum and maximum values a `signed int' can hold.  }
  INT_MAX = 2147483647;
  SEM_VALUE_MAX = INT_MAX;
  __PTW32_VERSION_MAJOR = 3;
  __PTW32_FALSE = False;
  __PTW32_TRUE = True;

  
type
  PVOID = Pointer;
  LPVOID = Pointer;
  wchar_t = System.UCS4Char;
  WCHAR = WideChar;
  DWORD = Cardinal;
  ULONG_PTR = NativeUInt;
  DWORD_PTR = ULONG_PTR;
  THandle = System.THandle;
  PHandle = ^THandle;
  Pwchar_t = System.PUCS4Char;
  PPwchar_t = ^Pwchar_t;
  UTF8Char = AnsiChar;
  {$ifndef FPC}
  {$if CompilerVersion <= 23}
  LPCSTR = PAnsichar;
  {$IFEND}
  {$ELSE}
   LPCSTR = MarshaledAString;
  {$ENDIF}

  __PTW32_INTERLOCKED_PVOID_PTR  = ^PVOID;
  __PTW32_INTERLOCKED_LONG = Integer;
  __PTW32_INTERLOCKED_LONGPTR = PInteger;
  {$if defined(_WIN64)}
  #  define  __PTW32_INTERLOCKED_SIZE LONGLONG
  #  define  __PTW32_INTERLOCKED_SIZEPTR  __PTW32_INTERLOCKED_VOLATILE LONGLONG*
  {$else }
     __PTW32_INTERLOCKED_SIZE = Integer;//long ;
     __PTW32_INTERLOCKED_SIZEPTR  = PInteger;
  {$ifend}
  //#define  __PTW32_INTERLOCKED_PVOID PVOID
   __PTW32_INTERLOCKED_PVOID = PVOID;
  __Pptw32_mcs_node_t_ = ^__ptw32_mcs_node_t_;
  __PPptw32_mcs_node_t_ = ^__Pptw32_mcs_node_t_ ;

  //typedef struct __ptw32_mcs_node_t_*    __ptw32_mcs_lock_t;
  __ptw32_mcs_lock_t =  ^__ptw32_mcs_node_t_;
  __Pptw32_mcs_lock_t = ^__ptw32_mcs_lock_t;

  __ptw32_mcs_node_t_ = record

    lock                : __Pptw32_mcs_lock_t;
    next                : __ptw32_mcs_lock_t;
    readyFlag,
    nextFlag            : THANDLE;
 end;

  __ptw32_mcs_local_node_t = __ptw32_mcs_node_t_ ;
  __Pptw32_mcs_local_node_t = ^__ptw32_mcs_local_node_t;


  // Forward declarations
  sched_param = record
    sched_priority: Integer;
  end;

 {$IFNDEF  USE_CJMP}
 jmp_buf = record
    EBX,
    ESI,
    EDI,
    ESP,
    EBP,
    EIP: longword;
  end;
{$ELSE}
  jmp_buf = array[0.._NSETJMP-1] of Integer;
{$ENDIF}

  _sched_cpu_set_vector_ = record
     case integer of
       0: (cpuset : array[0..(CPU_SETSIZE div 8)-1] of byte);
       1: (_cpuset : size_t);
   end;

   TPAPC_FUNC = procedure(dwParam: DWORD);
   PAPCFUNC = ^TPAPC_FUNC;
   __ptw32_register_cancellation_fun = function (func: PAPCFUNC; handle: THANDLE; p1: DWORD): DWORD;
   __Pptw32_register_cancellation_fun = ^__ptw32_register_cancellation_fun;

  _Psched_cpu_set_vector_ = ^_sched_cpu_set_vector_;
  pthread_attr_t_ = record
    valid: ulong;

    stackaddr       : pointer;
    stacksize       : size_t;
    detachstate     : integer;
    param           : sched_param;
    inheritsched,
    contentionscope : integer;
    cpuset          : size_t;
    thrname         : PChar;
    {$if defined(HAVE_SIGSET_T)}
    sigmask         : sigset_t;
    {$IFEND}
  end;

  PNativeUInt = ^NativeUInt;
 
  Ppthread_key_t_ = Pointer;
  PPpthread_key_t_ = ^Ppthread_key_t_;
  Ppthread_mutex_t_ = Pointer;
  PPpthread_mutex_t_ = ^Ppthread_mutex_t_;

  
  Ppthread_cond_t_ = Pointer;
  PPpthread_cond_t_ = ^Ppthread_cond_t_;
  Ppthread_condattr_t_ = Pointer;
  PPpthread_condattr_t_ = ^Ppthread_condattr_t_;
  Ppthread_rwlock_t_ = Pointer;
  PPpthread_rwlock_t_ = ^Ppthread_rwlock_t_;
  Ppthread_rwlockattr_t_ = Pointer;
  PPpthread_rwlockattr_t_ = ^Ppthread_rwlockattr_t_;
  Ppthread_spinlock_t_ = Pointer;
  PPpthread_spinlock_t_ = ^Ppthread_spinlock_t_;
  Ppthread_barrier_t_ = Pointer;
  PPpthread_barrier_t_ = ^Ppthread_barrier_t_;
  Ppthread_barrierattr_t_ = Pointer;
  PPpthread_barrierattr_t_ = ^Ppthread_barrierattr_t_;
  time_t = {$IFDEF Win32} Integer {$ENDIF}
           {$IFDEF Win64} Int64 {$ENDIF};
  timespec = record
    tv_sec   : time_t;
    tv_nsec  : integer;
  end;
  Ptimespec = ^timespec;
  PPtimespec = ^Ptimespec;

  sem_t_ = record
    value         : integer;
    lock          : __ptw32_mcs_lock_t;
    sem           : THANDLE;
    {$if defined(NEED_SEM)}
    leftToUnblock : integer;
    {$IFEND}
  end;
  //typedef struct sem_t_ * sem_t;
  sem_t = ^sem_t_;
  Psem_t = ^sem_t;
  //PPsem_t_ = ^Psem_t_;
  Psched_param = ^sched_param;

  Ppthread_once_t_ = ^pthread_once_t_;
  P__ptw32_cleanup_t = ^__ptw32_cleanup_t;

 
  int64_t = Int64;
  uint64_t = UInt64;
  Puint64_t = ^uint64_t;



  pid_t = Integer;

  _anonymous_type_2 = (
    SCHED_OTHER = 0,
    SCHED_FIFO = 1,
    SCHED_RR = 2,
    SCHED_MIN = 0,
    SCHED_MAX = 2);
  P_anonymous_type_2 = ^_anonymous_type_2;

  

  cpu_set_t = record
    case Integer of
      0: (cpuset: array [0..(CPU_SETSIZE div 8 -1)] of UTF8Char);// = (#0,#0,#0,#0,#0,#0,#0,#0));
      1: (_align: NativeUInt);
  end;
  Pcpu_set_t = ^cpu_set_t;

  pthread_t = record
    p: Pointer;
    x: NativeUInt;
  end;

{$if  __PTW32_VERSION_MAJOR > 2}

//#define PTHREAD_ONCE_INIT       { 0,  __PTW32_FALSE }
 pthread_once_t_  = record
  lock: Pointer;		(* MCS lock *)
  done: int;    	(* indicates if user function has been executed *)
 end;
{$else}
//#define PTHREAD_ONCE_INIT       {  __PTW32_FALSE, 0, 0, 0 }
pthread_once_t_ = record
  done: int;       	(* indicates if user function has been executed *)
  lock: Pointer;		(* MCS lock *)
  reserved1,
  reserved2: int;
end;
{$IFEND}

  Ppthread_t = ^pthread_t;

  PThreadState = (
  PThreadStateInitial = 0,	(* Thread not running                   *)
  PThreadStateReuse,            (* In reuse pool.                       *)
  PThreadStateRunning,		(* Thread alive & kicking               *)
  PThreadStateSuspended,	(* Thread alive but suspended           *)
  PThreadStateCancelPending,	(* Thread alive but                     *)
                                (* has cancellation pending.            *)
  PThreadStateCanceling,	(* Thread alive but is                  *)
                                (* in the process of terminating        *)
                                (* due to a cancellation request        *)
  PThreadStateExiting,		(* Thread alive but exiting             *)
                                (* due to an exception                  *)
  PThreadStateLast );

  __Pptw32_robust_node_t = ^__ptw32_robust_node_t;
  __PPptw32_robust_node_t = ^__Pptw32_robust_node_t;

  __Pptw32_thread_t = ^__ptw32_thread_t;
  __ptw32_thread_t_ = record
      seqNumber      : uint64;
      threadH        : THANDLE;
      ptHandle       : pthread_t;
      prevReuse      : __Pptw32_thread_t;
      {$IFnDEF FPC}[volatile]{$ENDIF} state          : PThreadState;
      threadLock,
      stateLock      : __ptw32_mcs_lock_t;
      cancelEvent    : THANDLE;
      exitStatus,
      parms,
      keys,
      nextAssoc      : pointer;
      {$if defined(__PTW32_CLEANUP_C)}
      start_mark     : jmp_buf;
      {$ifend}
      {$if defined(HAVE_SIGSET_T)}
      sigmask        : sigset_t;
      {$ifend}
      robustMxListLock : __ptw32_mcs_lock_t;
      robustMxList     : __Pptw32_robust_node_t;
      ptErrno,
      detachState,
      sched_priority,
      cancelState,
      cancelType,
      implicit     : integer;
      thread         : DWORD;
      {$if defined(HAVE_CPU_AFFINITY)}
      cpuset         : size_t;
      {$ifend}
      name           : Pchar;
      {$if defined(_UWIN)}
      dummy          : array[0..4] of DWORD;
      {$ifend}
      align          : size_t;

  end;
  __ptw32_thread_t = __ptw32_thread_t_;

  //typedef struct pthread_attr_t_ * pthread_attr_t;
  pthread_attr_t = ^pthread_attr_t_;
  Ppthread_attr_t = ^pthread_attr_t;
  //typedef struct pthread_once_t_ pthread_once_t;
  pthread_once_t = pthread_once_t_;
  Ppthread_once_t = ^pthread_once_t;

  Tdestructor = procedure(p: Pointer);
  Pdestructor = ^Tdestructor;
  pthread_key_t_ = record
    key            : DWORD;
    _destructor    : Pdestructor;
    keyLock        : __ptw32_mcs_lock_t;
    threads        : pointer;
  end;
  //typedef struct pthread_key_t_ * pthread_key_t;
  pthread_key_t = ^pthread_key_t_;
  Ppthread_key_t = ^pthread_key_t;

  __ptw32_robust_state_t_ = (

   __PTW32_ROBUST_CONSISTENT,
   __PTW32_ROBUST_INCONSISTENT,
   __PTW32_ROBUST_NOTRECOVERABLE
 );
  __ptw32_robust_state_t = __ptw32_robust_state_t_;

  pthread_mutex_t_ = record
    lock_idx         : LONG;
    recursive_count,
    kind             : integer;
    ownerThread      : pthread_t;
    event            : THANDLE;
    robustNode       : __Pptw32_robust_node_t;
  end;

  pthread_mutex_t = ^pthread_mutex_t_;
  Ppthread_mutex_t = ^pthread_mutex_t;

  __ptw32_robust_node_t_ = record

    mx                     : pthread_mutex_t;
    stateInconsistent      : __ptw32_robust_state_t;
    prev,
    next                   : __Pptw32_robust_node_t;
  end;
  __ptw32_robust_node_t = __ptw32_robust_node_t_;

  pthread_mutexattr_t_ = record

    pshared,
    kind,
    robustness           : integer;
  end;

  pthread_mutexattr_t = ^pthread_mutexattr_t_;
  Ppthread_mutexattr_t = ^pthread_mutexattr_t;

  pthread_cond_t = ^pthread_cond_t_;
  pthread_cond_t_ = record
    nWaitersBlocked,
    nWaitersGone,
    nWaitersToUnblock : long;
    semBlockQueue,
    semBlockLock      : sem_t;
    mtxUnblockLock    : pthread_mutex_t;
    next,
    prev              : pthread_cond_t;
  end;


  Ppthread_cond_t = ^pthread_cond_t;
  pthread_condattr_t_ = record
    pshared             : integer;
  end;
  pthread_condattr_t = ^pthread_condattr_t_;
  Ppthread_condattr_t = ^pthread_condattr_t;

  pthread_rwlockattr_t_ = record

    pshared: int ;
  end;
  pthread_rwlockattr_t = ^pthread_rwlockattr_t_ ;
  Ppthread_rwlockattr_t = ^pthread_rwlockattr_t;

  _U = record
    case integer of

       0: (cpus  : integer);
       1: (mutex : pthread_mutex_t);
   end;
  pthread_spinlock_t_ = record

    interlock           : long;
    u: _U
  end;

  pthread_spinlock_t = ^pthread_spinlock_t_ ;
  Ppthread_spinlock_t = ^pthread_spinlock_t;

  pthread_barrier_t_ = record
    nCurrentBarrierHeight,
    nInitialBarrierHeight : uint32;
    pshared               : integer;
    semBarrierBreeched    : sem_t;
    lock                  : __ptw32_mcs_lock_t;
    proxynode             : __ptw32_mcs_local_node_t;
  end;
  //typedef struct pthread_barrier_t_ * pthread_barrier_t;
  pthread_barrier_t = ^pthread_barrier_t_;
  Ppthread_barrier_t = ^pthread_barrier_t;

  pthread_barrierattr_t_ = record

    pshared: int;
  end;
  pthread_barrierattr_t = ^pthread_barrierattr_t_;
  Ppthread_barrierattr_t = ^pthread_barrierattr_t;

  _anonymous_type_3 = (
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1,
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1,
    PTHREAD_SCOPE_PROCESS = 0,
    PTHREAD_SCOPE_SYSTEM = 1,
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1,
    PTHREAD_CANCEL_ASYNCHRONOUS = 0,
    PTHREAD_CANCEL_DEFERRED = 1,
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1,
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_BARRIER_SERIAL_THREAD = -1);
  P_anonymous_type_3 = ^_anonymous_type_3;

  _anonymous_type_4 = (
    PTHREAD_MUTEX_FAST_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_TIMED_NP = PTHREAD_MUTEX_FAST_NP,
    PTHREAD_MUTEX_ADAPTIVE_NP = PTHREAD_MUTEX_FAST_NP,
    (* For compatibility with POSIX *)
    PTHREAD_MUTEX_NORMAL = 0,//PTHREAD_MUTEX_FAST_NP,
    PTHREAD_MUTEX_RECURSIVE = 1,//PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK = 2,//PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_DEFAULT = 0) ;//PTHREAD_MUTEX_NORMAL);
  P_anonymous_type_4 = ^_anonymous_type_4;

  __ptw32_cleanup_callback_t_ = procedure(arg: Pointer);
  __ptw32_cleanup_callback_t = ^__ptw32_cleanup_callback_t_;
  __ptw32_cleanup_t = record
    routine: __ptw32_cleanup_callback_t;
    arg: Pointer;
    prev: P__ptw32_cleanup_t;
  end;

  __ptw32_features_t = (
    __PTW32_SYSTEM_INTERLOCKED_COMPARE_EXCHANGE = $0001,
    __PTW32_ALERTABLE_ASYNC_CANCEL = $0002);
  P__ptw32_features = ^__ptw32_features_t;

   pthread_rwlock_t_ = record


    mtxExclusiveAccess,
    mtxSharedAccessCompleted    : pthread_mutex_t;
    cndSharedAccessCompleted    : pthread_cond_t;
    nSharedAccessCount,
    nExclusiveAccessCount,
    nCompletedSharedAccessCount,
    nMagic                      : integer;
  end;
  pthread_rwlock_t = ^pthread_rwlock_t_;
  Ppthread_rwlock_t = ^pthread_rwlock_t;

function sched_yield(): Integer; 
function sched_get_priority_min(policy: Integer): Integer; 

function sched_get_priority_max(policy: Integer): Integer; 

function sched_setscheduler(pid: pid_t; policy: Integer): Integer; 

function sched_setaffinity(pid: pid_t; cpusetsize: NativeUInt; &set: Pcpu_set_t): Integer; 

function sched_getaffinity(pid: pid_t; cpusetsize: NativeUInt; &set: Pcpu_set_t): Integer;

function _sched_affinitycpucount(const &set: Pcpu_set_t): Integer; 


procedure _sched_affinitycpuzero(pset: Pcpu_set_t);

procedure _sched_affinitycpuset(cpu: Integer; pset: Pcpu_set_t); 

procedure _sched_affinitycpuclr(cpu: Integer; pset: Pcpu_set_t); 

function _sched_affinitycpuisset(cpu: Integer; const pset: Pcpu_set_t): Boolean; 

procedure _sched_affinitycpuand(pdestset: Pcpu_set_t; const psrcset1: Pcpu_set_t; const psrcset2: Pcpu_set_t); 

procedure _sched_affinitycpuor(pdestset: Pcpu_set_t; const psrcset1: Pcpu_set_t; const psrcset2: Pcpu_set_t); 

procedure _sched_affinitycpuxor(pdestset: Pcpu_set_t; const psrcset1: Pcpu_set_t; const psrcset2: Pcpu_set_t); 

function _sched_affinitycpuequal(const pset1: Pcpu_set_t; const pset2: Pcpu_set_t): Boolean; 




type
  start_func = function (p: Pointer): Pointer;
  Pstart_func = ^start_func;

function pthread_create(tid: Ppthread_t; const attr: Ppthread_attr_t; start: Pstart_func; arg: Pointer): Integer;

function pthread_detach(thread: pthread_t): Integer;

function pthread_equal(t1: pthread_t; t2: pthread_t):Boolean;

procedure pthread_exit(value_ptr: Pointer); 

function pthread_join(thread: pthread_t; value_ptr: PPointer): Integer;

function pthread_self(): pthread_t; 

function pthread_cancel(thread: pthread_t): Integer; 

function pthread_setcancelstate(state: Integer; oldstate: PInteger): Integer; 
function pthread_setcanceltype(&type: Integer; oldtype: PInteger): Integer; 

procedure pthread_testcancel(); 

type
  Tpthread_once_init_routine = procedure();
  Ppthread_once_init_routine = ^Tpthread_once_init_routine;
function pthread_once(once_control: Ppthread_once_t; init_routine: Ppthread_once_init_routine): Integer;

function __ptw32_pop_cleanup(execute: Integer): P__ptw32_cleanup_t;

procedure __ptw32_push_cleanup(cleanup: P__ptw32_cleanup_t; routine: __ptw32_cleanup_callback_t; arg: Pointer);

type
  pthread_key_create_destructor = procedure(p1: Pointer);

function pthread_key_create(key: Ppthread_key_t; _destructor: Pdestructor): Integer;

function pthread_key_delete(key: pthread_key_t): Integer; 

function pthread_setspecific(key: pthread_key_t; const value: Pointer): Integer; 

function pthread_getspecific(key: pthread_key_t): Pointer; 

function pthread_mutexattr_init(attr: Ppthread_mutexattr_t): Integer; 

function pthread_mutexattr_destroy(attr: Ppthread_mutexattr_t): Integer; 

function pthread_mutexattr_getpshared(const attr: Ppthread_mutexattr_t; pshared: PInteger): Integer; 

function pthread_mutexattr_setpshared(attr: Ppthread_mutexattr_t; pshared: Integer): Integer; 

function pthread_mutexattr_settype(attr: Ppthread_mutexattr_t; kind: Integer): Integer; 

function pthread_mutexattr_gettype(const attr: Ppthread_mutexattr_t; kind: PInteger): Integer; 

function pthread_mutexattr_setrobust(attr: Ppthread_mutexattr_t; robust: Integer): Integer; 

function pthread_mutexattr_getrobust(const attr: Ppthread_mutexattr_t; robust: PInteger): Integer;

function pthread_barrierattr_init(attr: Ppthread_barrierattr_t): Integer; 
function pthread_barrierattr_destroy(attr: Ppthread_barrierattr_t): Integer;


function pthread_barrierattr_getpshared(const attr: Ppthread_barrierattr_t; pshared: PInteger): Integer;


function pthread_barrierattr_setpshared(attr: Ppthread_barrierattr_t; pshared: Integer): Integer;

function pthread_mutex_init(mutex: Ppthread_mutex_t; const attr: Ppthread_mutexattr_t): Integer; 

function pthread_mutex_destroy(mutex: Ppthread_mutex_t): Integer; 

function pthread_mutex_lock(mutex: Ppthread_mutex_t): Integer;

function pthread_mutex_timedlock(mutex: Ppthread_mutex_t; const abstime: Ptimespec): Integer;

function pthread_mutex_trylock(mutex: Ppthread_mutex_t): Integer; 

function pthread_mutex_unlock(mutex: Ppthread_mutex_t): Integer; 

function pthread_mutex_consistent(mutex: Ppthread_mutex_t): Integer; 

function pthread_spin_init(lock: Ppthread_spinlock_t; pshared: Integer): Integer; 

function pthread_spin_destroy(lock: Ppthread_spinlock_t): Integer; 

function pthread_spin_lock(lock: Ppthread_spinlock_t): Integer; 

function pthread_spin_trylock(lock: Ppthread_spinlock_t): Integer; 

function pthread_spin_unlock(lock: Ppthread_spinlock_t): Integer; 

function pthread_barrier_wait(barrier: Ppthread_barrier_t): Integer;


function pthread_condattr_init(attr: Ppthread_condattr_t): Integer; 

function pthread_condattr_destroy(attr: Ppthread_condattr_t): Integer;

function pthread_condattr_getpshared(const attr: Ppthread_condattr_t; pshared: PInteger): Integer; 

function pthread_condattr_setpshared(attr: Ppthread_condattr_t; pshared: Integer): Integer;

function pthread_cond_init(cond: Ppthread_cond_t; const attr: Ppthread_condattr_t): Integer;

function pthread_cond_destroy(cond: Ppthread_cond_t): Integer;

function pthread_cond_wait(cond: Ppthread_cond_t; mutex: Ppthread_mutex_t): Integer;

function pthread_cond_timedwait(cond: Ppthread_cond_t; mutex: Ppthread_mutex_t; const abstime: Ptimespec): Integer; 
function pthread_cond_signal(cond: Ppthread_cond_t): Integer; 

function pthread_cond_broadcast(cond: Ppthread_cond_t): Integer; 

function pthread_setschedparam(thread: pthread_t; policy: Integer; const param: Psched_param): Integer; 

function pthread_getschedparam(thread: pthread_t; policy: PInteger; param: Psched_param): Integer; 

function pthread_setconcurrency(level: Integer): Integer;

function pthread_getconcurrency(): Integer; 

function pthread_rwlock_init(rwlock: Ppthread_rwlock_t; const attr: Ppthread_rwlockattr_t): Integer;

function pthread_rwlock_destroy(rwlock: Ppthread_rwlock_t): Integer;

function pthread_rwlock_tryrdlock(rwlock: Ppthread_rwlock_t): Integer;

function pthread_rwlock_trywrlock(rwlock: Ppthread_rwlock_t): Integer;

function pthread_rwlock_rdlock(rwlock: Ppthread_rwlock_t): Integer;

function pthread_rwlock_timedrdlock(rwlock: Ppthread_rwlock_t; const abstime: Ptimespec): Integer;

function pthread_rwlock_wrlock(rwlock: Ppthread_rwlock_t): Integer;

function pthread_rwlock_timedwrlock(rwlock: Ppthread_rwlock_t; const abstime: Ptimespec): Integer;

function pthread_rwlock_unlock(rwlock: Ppthread_rwlock_t): Integer;

function pthread_rwlockattr_init(attr: Ppthread_rwlockattr_t): Integer; 

function pthread_rwlockattr_destroy(attr: Ppthread_rwlockattr_t): Integer; 

function pthread_rwlockattr_getpshared(const attr: Ppthread_rwlockattr_t; pshared: PInteger): Integer; 

function pthread_rwlockattr_setpshared(attr: Ppthread_rwlockattr_t; pshared: Integer): Integer; 

function pthread_kill(thread: pthread_t; sig: Integer): Integer; 

function pthread_mutexattr_setkind_np(attr: Ppthread_mutexattr_t; kind: Integer): Integer; 

function pthread_mutexattr_getkind_np(attr: Ppthread_mutexattr_t; kind: PInteger): Integer;

function pthread_timedjoin_np(thread: pthread_t; value_ptr: PPointer; const abstime: Ptimespec): Integer; 

function pthread_tryjoin_np(thread: pthread_t; value_ptr: PPointer): Integer; 
function pthread_setaffinity_np(thread: pthread_t; cpusetsize: NativeUInt; const cpuset: Pcpu_set_t): Integer; 

function pthread_getaffinity_np(thread: pthread_t; cpusetsize: NativeUInt; cpuset: Pcpu_set_t): Integer;

function pthread_delay_np(interval: Ptimespec): Integer;

function pthread_num_processors_np(): Integer;

function pthread_getunique_np(thread: pthread_t): UInt64; 

function pthread_win32_process_attach_np(): integer;

function pthread_win32_process_detach_np(): Boolean;

function pthread_win32_thread_attach_np(): Boolean;

function pthread_win32_thread_detach_np(): Boolean;

function pthread_win32_getabstime_np(abstime: Ptimespec; const relative: Ptimespec): Ptimespec; 

function pthread_win32_test_features_np(feature_mask: Integer): Boolean;

function pthread_timechange_handler_np(arg: Pointer): Pointer;

function pthread_getw32threadhandle_np(thread: pthread_t): THandle;

function pthread_getw32threadid_np(thread: pthread_t): Cardinal; 

function pthread_setname_np(thr: pthread_t; const name: PChar): Integer;

function pthread_getname_np(thr: pthread_t; name: PChar; len: Integer): Integer;



function pthreadCancelableWait(waitHandle: THandle): Integer;

function pthreadCancelableTimedWait(waitHandle: THandle; timeout: Cardinal): Integer;

function __ptw32_get_exception_services_code(): Cardinal; 

function sem_init(sem: Psem_t; pshared: Integer; value: Cardinal): Integer; 
function sem_destroy(sem: Psem_t): Integer; 

function sem_trywait(sem: Psem_t): Integer; 

function sem_wait(sem: Psem_t): Integer; 
function sem_timedwait(sem: Psem_t; const abstime: Ptimespec): Integer; 

function sem_post(sem: Psem_t): Integer; 

function sem_post_multiple(sem: Psem_t; count: Integer): Integer; 

function sem_open(const name : Pchar; oflag : integer): Psem_t; //cdecl; varargs; 
function sem_close(sem: Psem_t): Integer; 

function sem_unlink(const name: PChar): Integer; 

function sem_getvalue(sem: Psem_t; sval: PInteger): Integer; 

function pthread_attr_destroy(attr: Ppthread_attr_t): Integer;
function __ptw32_calloc( n, s : size_t):Pointer;
function __ptw32_is_attr(const attr: Ppthread_attr_t): integer;
function pthread_attr_getaffinity_np(const attr: Ppthread_attr_t; cpusetsize: NativeUInt; cpuset: Pcpu_set_t): Integer;
function pthread_attr_getdetachstate(const attr: Ppthread_attr_t; detachstate: PInteger): Integer;
function pthread_attr_getinheritsched(const attr: Ppthread_attr_t; inheritsched: PInteger): Integer;
function pthread_attr_getname_np(attr: Ppthread_attr_t; name: PChar; len: Integer): Integer;
function pthread_attr_getschedparam(const attr: Ppthread_attr_t; param: Psched_param): Integer;
function pthread_attr_getschedpolicy(const attr: Ppthread_attr_t; policy: PInteger): Integer;
function pthread_attr_getscope(const attr: Ppthread_attr_t; contentionscope: PInteger): Integer;
function pthread_attr_getstackaddr(const attr: Ppthread_attr_t; stackaddr: PPointer): Integer;
function pthread_attr_getstacksize(const attr: Ppthread_attr_t; stacksize: PNativeUInt): Integer;
function pthread_attr_init(attr: Ppthread_attr_t):integer;
procedure CPU_ZERO(setptr: Pcpu_set_t);inline;
function pthread_attr_setaffinity_np(attr: Ppthread_attr_t; cpusetsize: NativeUInt; const cpuset: Pcpu_set_t): Integer;
function pthread_attr_setdetachstate(attr: Ppthread_attr_t; detachstate: Integer): Integer;
function pthread_attr_setinheritsched(attr: Ppthread_attr_t; inheritsched: Integer): Integer;
function pthread_attr_setschedparam(attr: Ppthread_attr_t; const param: Psched_param): Integer;
function pthread_attr_setschedpolicy(attr: Ppthread_attr_t; policy: Integer): Integer;
function pthread_attr_setstackaddr(attr: Ppthread_attr_t; stackaddr: Pointer): Integer;


function pthread_barrier_init(barrier: Ppthread_barrier_t; const attr: Ppthread_barrierattr_t; count: Cardinal): Integer;
procedure __ptw32_mcs_lock_acquire( Alock : __Pptw32_mcs_lock_t; node: __Pptw32_mcs_local_node_t);
function __ptw32_get_errno:integer;
function __ptw32_semwait( sem : Psem_t):integer;
function PTHREAD_CANCELED: Pointer; inline;
procedure __ptw32_mcs_flag_set(var flag : THANDLE);
procedure __ptw32_mcs_flag_wait(var flag : THANDLE);
procedure __ptw32_mcs_lock_release( node : __Pptw32_mcs_local_node_t);
function __ptw32_cond_timedwait(cond : Ppthread_cond_t; mutex : Ppthread_mutex_t; abstime : Ptimespec):integer;
function __ptw32_cond_check_need_init( cond : Ppthread_cond_t):integer;
procedure pthread_cleanup_pop( _execute: Integer );
procedure __ptw32_threadDestroy( thread : pthread_t);
function __ptw32_robust_mutex_inherit( mutex : Ppthread_mutex_t):integer;
procedure __ptw32_robust_mutex_add( mutex : Ppthread_mutex_t; self : pthread_t);
function __ptw32_mutex_check_need_init( mutex : Ppthread_mutex_t):integer;
function __ptw32_timed_eventwait(event : THANDLE;const abstime : Ptimespec):integer;
procedure __ptw32_robust_mutex_remove( mutex : Ppthread_mutex_t; otp : __Pptw32_thread_t);
function __ptw32_relmillisecs(const abstime : Ptimespec):DWORD;
//procedure pthread_cleanup_push( _rout: __Pptw32_mcs_local_node_t; _arg: Pointer ) ;
procedure pthread_cleanup_push(_rout, _arg: Pointer );
function __ptw32_rwlock_check_need_init( rwlock : Ppthread_rwlock_t):integer;
procedure __ptw32_rwlock_cancelwrwait( arg : Pointer);
procedure __ptw32_threadReusePush( thread : pthread_t);
function __ptw32_new:pthread_t;
function __ptw32_threadReusePop:pthread_t;
procedure CPU_AND(destsetptr, srcset1ptr, srcset2ptr: Pointer);
procedure __ptw32_throw( Aexception : DWORD);
function __ptw32_setthreadpriority( thread : pthread_t; policy, priority : integer):integer;
function __ptw32_tkAssocCreate( sp : __Pptw32_thread_t; key : pthread_key_t):integer;
function __ptw32_getprocessors(count : Pinteger):integer;
function __ptw32_spinlock_check_need_init( lock : Ppthread_spinlock_t):integer;
procedure __ptw32_processTerminate;
function __ptw32_Registercancellation( unused1 : PAPCFUNC; threadH : THANDLE; unused2 : DWORD):DWORD;
function __ptw32_mcs_lock_try_acquire( lock : __Pptw32_mcs_lock_t; node : __Pptw32_mcs_local_node_t):integer;
procedure __ptw32_callUserDestroyRoutines( thread : pthread_t);
procedure __ptw32_filetime_to_timespec(const ft : PFILETIME; ts : Ptimespec);
procedure __ptw32_set_errno( err : integer);
function CPU_EQUAL(const set1ptr, set2ptr: Pcpu_set_t): Boolean;
function CPU_COUNT(setptr: Pcpu_set_t): Integer;
procedure CPU_SET(cpu : integer; setptr : Pcpu_set_t);
function CPU_ISSET(cpu : integer;const setptr : Pcpu_set_t): Boolean;
procedure CPU_CLR(cpu : integer; setptr : Pcpu_set_t);
procedure CPU_OR(pdestset : Pcpu_set_t;const psrcset1 : Pcpu_set_t; const psrcset2 : Pcpu_set_t);
function sched_getscheduler( pid : pid_t):integer;
procedure CPU_XOR(pdestset : Pcpu_set_t;const psrcset1 : Pcpu_set_t;const psrcset2 : Pcpu_set_t) ;
procedure __ptw32_threadStart( vthreadParms : Pointer);
function pthread_barrier_destroy(barrier: Ppthread_barrier_t): Integer;


type
  __ptw32_cond_wait_cleanup_args_t = record
     mutexPtr  : Ppthread_mutex_t;
    cv        : pthread_cond_t;
    resultPtr : Pinteger;
  end;
  __Pptw32_cond_wait_cleanup_args_t = ^__ptw32_cond_wait_cleanup_args_t;

  PThreadKeyAssoc = ^ThreadKeyAssoc;
  ThreadKeyAssoc = record

    thread         : __Pptw32_thread_t;
    key            : pthread_key_t;
    nextKey,
    nextThread,
    prevKey,
    prevThread     : PThreadKeyAssoc;
  end;

  old_mutex_t_ = record
    mutex : THANDLE;
    cs : TRTLCriticalSection;
  end;
  //typedef struct old_mutex_t_ * old_mutex_t;
  old_mutex_t = ^old_mutex_t_;
  Pold_mutex_t = ^old_mutex_t;

  old_mutexattr_t_ = record
    pshared: int;
  end;
  old_mutexattr_t = ^old_mutexattr_t_ ;
  Pold_mutexattr_t = ^old_mutexattr_t;

  ThreadParms = record

    tid         : pthread_t;
    start       : Pstart_func;
    arg         : pointer;
  end;
  PThreadParms = ^ThreadParms;

  sem_timedwait_cleanup_args_t = record

    sem       : sem_t;
    resultPtr : Pinteger;
  end;
  Psem_timedwait_cleanup_args_t = ^sem_timedwait_cleanup_args_t;
  __ptw32_try_enter_critical_section_func= function(cs: PRTLCRITICALSECTION): BOOL;
  __Pptw32_try_enter_critical_section = ^__ptw32_try_enter_critical_section_func;
  Tptw32_cond_wait_cleanup = procedure (args: Pointer);
  HINSTANCE = THandle;              { HINSTANCE from widnef.h }
  queue_user_apc_ex_init_func = function(): BOOL;
  Pqueue_user_apc_ex_init = ^queue_user_apc_ex_init_func;
  queue_user_apc_ex_fini_func = function(): BOOL;
  Pqueue_user_apc_ex_fini = ^queue_user_apc_ex_fini_func;
  __ptw32_terminate_handler_func = procedure();
  __ptw32_terminate_handler = ^__ptw32_terminate_handler_func;
  function old_mutex_lock( mutex : Pold_mutex_t):integer;
  function old_mutex_unlock( mutex : Pold_mutex_t):integer;
  function old_mutex_trylock( mutex : Pold_mutex_t):integer;
  procedure __ptw32_tkAssocDestroy( assoc : PThreadKeyAssoc);
  function old_mutex_init(mutex : Pold_mutex_t;const attr : Pold_mutexattr_t):integer;
  function old_mutex_destroy( mutex : Pold_mutex_t):integer;
const
    OLD_WIN32CS = 0;
    OLD_WIN32MUTEX  =1;
    PTHREAD_COND_INITIALIZER = pthread_cond_t(size_t(-1));
    PTHREAD_MUTEX_INITIALIZER = pthread_mutex_t(size_t( -1));
    PTHREAD_RECURSIVE_MUTEX_INITIALIZER = pthread_mutex_t(size_t( -2));
    __PTW32_THREAD_REUSE_EMPTY = __Pptw32_thread_t(size_t( 1));
    PTHREAD_RWLOCK_INITIALIZER = pthread_rwlock_t(size_t( -1));
     __PTW32_RWLOCK_MAGIC = $facade2;
    PTHREAD_SPINLOCK_INITIALIZER = pthread_spinlock_t(size_t( -1));
    __PTW32_OBJECT_AUTO_INIT = Pointer(size_t( -1));
    PTHREAD_ERRORCHECK_MUTEX_INITIALIZER = pthread_mutex_t(size_t( -3));
    NANOSEC_PER_SEC      : int64 = 1000000000;
    NANOSEC_PER_MILLISEC : int64 = 1000000;
    MILLISEC_PER_SEC     : int64 = 1000 ;
    __PTW32_SPIN_INVALID     = (0);
    __PTW32_SPIN_UNLOCKED    = (1);
    __PTW32_SPIN_LOCKED      = (2);
    __PTW32_SPIN_USE_MUTEX   = (3);
    SEM_FAILED  = Psem_t (-1);
    (*
 * time between jan 1, 1601 and jan 1, 1970 in units of 100 nanoseconds
 *)
 __PTW32_TIMESPEC_TO_FILETIME_OFFSET: uint64_t =
	         uint64_t( 27111902 shl 32) + uint64_t( 3577643008);
var

   __ptw32_selfThreadKey : pthread_key_t = nil;
   __ptw32_cond_list_lock : __ptw32_mcs_lock_t = nil;
   __ptw32_cond_list_head: pthread_cond_t = nil;
   __ptw32_cond_list_tail: pthread_cond_t  = nil;
   __ptw32_cond_test_init_lock: __ptw32_mcs_lock_t  = nil;
   __ptw32_cleanupKey: pthread_key_t = nil;
   __ptw32_thread_reuse_lock :__ptw32_mcs_lock_t  = nil;
    __ptw32_threadReuseTop: __Pptw32_thread_t = __PTW32_THREAD_REUSE_EMPTY;
   __ptw32_threadReuseBottom : __Pptw32_thread_t = __PTW32_THREAD_REUSE_EMPTY;
   __ptw32_concurrency: int = 0;
   __ptw32_mutex_test_init_lock: __ptw32_mcs_lock_t = nil;
   __ptw32_rwlock_test_init_lock: __ptw32_mcs_lock_t = nil;
    __ptw32_recursive_mutexattr_s: pthread_mutexattr_t_ =
  (pshared:Int(PTHREAD_PROCESS_PRIVATE); kind:Int(PTHREAD_MUTEX_RECURSIVE); robustness:Int(PTHREAD_MUTEX_STALLED));
  __ptw32_errorcheck_mutexattr_s: pthread_mutexattr_t_ =
  (pshared:Int(PTHREAD_PROCESS_PRIVATE); kind:Int(PTHREAD_MUTEX_RECURSIVE); robustness:Int(PTHREAD_MUTEX_STALLED));
   __ptw32_recursive_mutexattr: pthread_mutexattr_t  = @__ptw32_recursive_mutexattr_s;
   __ptw32_errorcheck_mutexattr: pthread_mutexattr_t = @__ptw32_errorcheck_mutexattr_s;
   __ptw32_threadSeqNumber: uint64  = 0;
   __ptw32_spinlock_test_init_lock: __ptw32_mcs_lock_t  = nil;
   __ptw32_processInitialized: Int = Int(__PTW32_FALSE);
   __ptw32_features: int = 0;
   __ptw32_register_cancellation :__Pptw32_register_cancellation_fun = nil;
   __ptw32_try_enter_critical_section: __Pptw32_try_enter_critical_section = nil;
  // Handle to quserex.dll
   __ptw32_h_quserex, __ptw32_h_kernel32: HINSTANCE;
   old_mutex_use:int = OLD_WIN32CS;

implementation

{$IFDEF FPC}
procedure memset(var X; Value: Integer; Count: NativeInt );
begin
   FillChar(X, Count, VALUE);
end;
{$ENDIF}

function old_mutex_destroy( mutex : Pold_mutex_t):integer;
var

  mx : old_mutex_t;
begin
  result := 0;
  if (mutex = nil ) or  (mutex^ = nil) then begin
      Exit(EINVAL);
    end;
  if mutex^ <> old_mutex_t ( __PTW32_OBJECT_AUTO_INIT) then
  begin
      mx := mutex^;
      result := old_mutex_trylock(@mx);
      if result = 0 then
      begin
          mutex^ := nil;
          old_mutex_unlock(@mx);
          if mx.mutex = 0 then begin
              DeleteCriticalSection(mx.cs);
            end
          else
          begin
            if CloseHandle (mx.mutex)  then
               result := 0
            else
               result := EINVAL;
          end;
          if result = 0 then
          begin
              mx.mutex := 0;
              free(mx);
          end
          else

              mutex^ := mx;

      end;
  end
  else
    result := EINVAL;

  if __ptw32_try_enter_critical_section <> nil then
  begin
      FreeLibrary(__ptw32_h_kernel32);
      __ptw32_h_kernel32 := 0;
    end;

end;

function old_mutex_init(mutex : Pold_mutex_t;const attr : Pold_mutexattr_t):integer;
var

  mx : old_mutex_t;

  cs : TRTLCRITICALSECTION;
  label FAIL0 ;
begin
  result := 0;
  if mutex = nil then begin
      Exit(EINVAL);
    end;
  mx := old_mutex_t( calloc(1, sizeof( mx^)));
  if mx = nil then begin
      result := ENOMEM;
    end;
  mx.mutex := 0;
  if (attr <> nil) and  (attr^ <> nil)
       and  ( attr^.pshared = Int(PTHREAD_PROCESS_SHARED) )  then

  begin
    result := ENOSYS;
  end
  else
    begin

        {__ptw32_h_kernel32 := LoadLibrary('KERNEL32.DLL');
        __ptw32_try_enter_critical_section :=    GetProcAddress(__ptw32_h_kernel32, 'TryEnterCriticalSection');

        if __ptw32_try_enter_critical_section <> nil then }
        begin
            InitializeCriticalSection(&cs);
            //if __ptw32_try_enter_critical_section^(@cs) then
            if TryEnterCriticalSection(cs) then
            begin
              LeaveCriticalSection(&cs);
            end
            else
            begin

              __ptw32_try_enter_critical_section := nil;
            end;
            DeleteCriticalSection(&cs);
        end;
        {if __ptw32_try_enter_critical_section = nil then
        begin
            FreeLibrary(__ptw32_h_kernel32);
            __ptw32_h_kernel32 := 0;
        end; }
      if old_mutex_use = OLD_WIN32CS then
      begin
        InitializeCriticalSection(&mx.cs);
      end
      else
      if (old_mutex_use = OLD_WIN32MUTEX) then
      begin
           mx.mutex := CreateMutex (nil,
           FALSE,
           nil);
           if mx.mutex = 0 then
              result := EAGAIN;

      end
      else
      begin
        result := EINVAL;
      end;
    end;
  if (result <> 0)  and  (mx <> nil) then
  begin
      free(mx);
      mx := nil;
  end;
FAIL0:
  mutex^ := mx;

end;

function old_mutex_lock( mutex : Pold_mutex_t):integer;
var

  mx : old_mutex_t;
begin
  result := 0;
  if (mutex = nil)  or  (mutex^ = nil) then begin
      Exit(EINVAL);
    end;
  if mutex^ = old_mutex_t (__PTW32_OBJECT_AUTO_INIT) then
    begin

      result := EINVAL;
    end;
  mx := mutex^;
  if result = 0 then
  begin
      if mx.mutex = 0 then
      begin
        EnterCriticalSection(&mx.cs);
      end
      else
      begin
        if (WaitForSingleObject(mx.mutex, INFINITE) = WAIT_OBJECT_0) then
           result := 0
        else
           Result := EINVAL;
      end;
  end;

end;


function old_mutex_unlock( mutex : Pold_mutex_t):integer;
var

  mx : old_mutex_t;
begin
  result := 0;
  if (mutex = nil)  or  (mutex^ = nil) then begin
      Exit(EINVAL);
    end;
  mx := mutex^;
  if mx <> old_mutex_t( __PTW32_OBJECT_AUTO_INIT)  then
    begin
      if mx.mutex = 0 then
      begin
        LeaveCriticalSection(&mx.cs);
      end
      else
      begin
        if ReleaseMutex (mx.mutex)  then
           result := 0
        else
           result := EINVAL;
      end;
    end
    else
    begin
      result := EINVAL;
    end;

end;


function old_mutex_trylock( mutex : Pold_mutex_t):integer;
var

  mx : old_mutex_t;
  status : DWORD;
begin
  result := 0;
  if (mutex = nil)  or  (mutex^ = nil) then begin
      Exit(EINVAL);
    end;
  if mutex^ = old_mutex_t  (__PTW32_OBJECT_AUTO_INIT) then
    begin

      result := EINVAL;
    end;
  mx := mutex^;
  if result = 0 then
  begin
      if mx.mutex = 0 then
      begin
        if __ptw32_try_enter_critical_section = nil then
        begin
          result := 0;
        end
        else
        if __ptw32_try_enter_critical_section^(@mx.cs) <> TRUE then

            result := EBUSY;

      end
      else
      begin
        status := WaitForSingleObject (mx.mutex, 0);
        if status <> WAIT_OBJECT_0 then
        begin
          if (status = WAIT_TIMEOUT) then
             result := EBUSY
          else
             Result := EINVAL;
        end;
      end;
  end;

end;


function sched_yield:integer;
begin
  Sleep (0);
  Result := 0;
end;

function __PTW32_MAX(a,b: Integer): Integer;inline;
begin
  if a<b then
    exit(b)
  else
    exit(a);
end;

function __PTW32_MIN(a,b: Integer): Integer;inline;
begin
  if a>b then
    exit(b)
  else
    exit(a);
end;

function pthread_cond_init(cond: Ppthread_cond_t; const attr: Ppthread_condattr_t): Integer;
var

  cv : pthread_cond_t;
  node : __ptw32_mcs_local_node_t;
  label  DONE, FAIL0, FAIL1, FAIL2;
begin
  cv := nil;
  if cond = nil then
      Exit(EINVAL);

  if (attr <> nil)  and  (attr^ <> nil)   and
     (attr^.pshared = Int(PTHREAD_PROCESS_SHARED))  then
      result := ENOSYS;

  cv := pthread_cond_t( calloc (1, sizeof (cv^)));
  if cv = nil then
      result := ENOMEM;

  cv.nWaitersBlocked := 0;
  cv.nWaitersToUnblock := 0;
  cv.nWaitersGone := 0;
  if sem_init (@cv.semBlockLock , 0, 1) <> 0   then
  begin
      result := __PTW32_GET_ERRNO();
      goto FAIL0;
  end;

  if sem_init (@cv.semBlockQueue , 0, 0) <> 0  then
  begin
      result := __PTW32_GET_ERRNO();
      goto FAIL1;
  end;

  result := pthread_mutex_init (@cv.mtxUnblockLock , nil);
  if result <> 0 then
  begin
    goto FAIL2;
  end;
  result := 0;

FAIL2:
  sem_destroy (@cv.semBlockQueue);
FAIL1:
  sem_destroy (@cv.semBlockLock);
FAIL0:
  free (cv);
  cv := nil;
DONE:
  if 0 = result then
  begin
      __ptw32_mcs_lock_acquire(@__ptw32_cond_list_lock, @node);
      cv.next := nil;
      cv.prev := __ptw32_cond_list_tail;
      if __ptw32_cond_list_tail <> nil then
      begin
         __ptw32_cond_list_tail.next := cv;
      end;
      __ptw32_cond_list_tail := cv;
      if __ptw32_cond_list_head = nil then
      begin
        __ptw32_cond_list_head := cv;
      end;
      __ptw32_mcs_lock_release(@node);
    end;
  cond^ := cv;
  Exit(result);
end;


function __ptw32_get_errno:integer;
var
  err : integer;
begin
  err := 0;
  _get_errno(@err);
  Result := err;
end;

{$if defined(_M_IX86) or defined(_X86_) and not defined(__amd64__)}
   procedure __PTW32_PROGCTR(var Context: TContext; value: DWORD_PTR);
   begin
      {$IFnDEF FPC}
         Context.Eip := value;
      {$ELSE}
         Context.Eip := value;
      {$ENDIF}
   end;
{$IFEND}

 {$if defined (_M_IA64) or defined(_IA64)}
{$define  __PTW32_PROGCTR(Context)  ((Context).StIIP)}
{$ifend}

{$if defined(_MIPS_) or defined(MIPS)}
{$define  __PTW32_PROGCTR(Context)  ((Context).Fir)}
{$ifend}

{$if defined(_ALPHA_)}
{$define  __PTW32_PROGCTR(Context)  ((Context).Fir)}
{$ifend}

{$if defined(_PPC_)}
{$define  __PTW32_PROGCTR(Context)  ((Context).Iar)}
{$ifend}

{$if defined(_AMD64_) or defined(__amd64__)}
{$define  __PTW32_PROGCTR(Context)  ((Context).Rip)}
{$ifend}

{$if defined(_ARM_) or defined(ARM) or defined(_M_ARM) or defined(_M_ARM64)}
{$define PTW32_PROGCTR(Context)  ((Context).Pc)}
{$ifend}

function PTHREAD_CANCELED: Pointer;
begin
   Result := Pointer(size_t( -1));
end;

function  __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(var Destination: LONG; Exchange: LONG; Comparand: LONG): LONG;
begin
    Result := InterlockedCompareExchange(Destination, Exchange, Comparand);
end;

function __PTW32_INTERLOCKED_EXCHANGE_LONG(var Target: LONG; Value: LONG): LONG;
begin
   Result := InterlockedExchange(Target, Value);
end;

function  __PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(var Addend: LONG; Value: LONG): LONG;
begin
   Result := InterlockedExchangeAdd(Addend, Value);
end;

function  __PTW32_INTERLOCKED_INCREMENT_LONG(var Addend: LONG): LONG;
begin
   Result := InterlockedIncrement(Addend);
end;

function  __PTW32_INTERLOCKED_DECREMENT_LONG(var Addend: LONG): LONG;
begin
   Result := InterlockedDecrement(Addend);
end;

function  __PTW32_INTERLOCKED_COMPARE_EXCHANGE_PTR(var Destination: Pointer; Exchange: Pointer; Comparand: Pointer): Pointer;
begin
   RESULT := InterlockedCompareExchangePointer(Destination, Exchange, Comparand);
end;

// lazarus 下 "var Target" 编译通过，delphi下报E20033错误
function  __PTW32_INTERLOCKED_EXCHANGE_PTR({var} Target: Pointer; Value: Pointer): Pointer;
begin
   RESULT := InterlockedExchangePointer(Target, Value);
end;



function __PTW32_INTERLOCKED_COMPARE_EXCHANGE_SIZE(var p: LONG; v: LONG; c: LONG): LONG;
begin
   Result := __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(p,v,c);
end;

function  __PTW32_INTERLOCKED_EXCHANGE_SIZE(var p: LONG; v: LONG): LONG;
begin
   Result := __PTW32_INTERLOCKED_EXCHANGE_LONG(p,v);
end;

function  __PTW32_INTERLOCKED_EXCHANGE_ADD_SIZE(p: LONG; v: LONG): LONG;
begin
   Result := __PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(p, v)   ;
end;

function  __PTW32_INTERLOCKED_INCREMENT_SIZE(p: Integer): Integer;
begin
   Result :=  __PTW32_INTERLOCKED_INCREMENT_LONG(p);
end;

function  __PTW32_INTERLOCKED_DECREMENT_SIZE(p: Integer): Integer;
begin
   Result :=  __PTW32_INTERLOCKED_DECREMENT_LONG(p);
end;

function CPU_COUNT(setptr: Pcpu_set_t): Integer;
begin
  Result  := _sched_affinitycpucount(setptr);
end;
function CPU_EQUAL(const set1ptr, set2ptr: Pcpu_set_t): Boolean;
begin
   Result := _sched_affinitycpuequal(set1ptr,set2ptr);
end;

function pthread_create(tid : Ppthread_t;const attr : Ppthread_attr_t;start : Pstart_func; arg : Pointer):integer;
var
  thread      : pthread_t;
  tp,
  sp          : __Pptw32_thread_t;
  a           : pthread_attr_t;
  threadH     : THANDLE;
  run         : integer;
  parms       : PThreadParms;
  stackSize   : uint32;
  priority    : integer;
  none,
  attr_cpuset : cpu_set_t;
  stateLock   : __ptw32_mcs_local_node_t;
  label FAIL0;

begin
  threadH := 0;
  result := EAGAIN;
  run := Int(__PTW32_TRUE);
  parms := nil;

  tid.x := 0;
  sp := __Pptw32_thread_t (pthread_self().p);
  if nil = sp then
    goto FAIL0;
  if attr <> nil then
  begin
    a := attr^;
  end
  else
  begin
    a := nil;
  end;
  thread := __ptw32_new();
  if thread.p = nil then
     goto FAIL0;
  tp := __Pptw32_thread_t ( thread.p);
  priority := tp.sched_priority;
  parms := PThreadParms (malloc (sizeof ( parms^)));
  if parms = nil then
    goto FAIL0;
  parms.tid := thread;
  parms.start := start;
  parms.arg := arg;

{$IF defined(HAVE_SIGSET_T)}
  tp.sigmask := sp.sigmask;
{$ifend}
{$IF defined(HAVE_CPU_AFFINITY)}
  tp.cpuset := sp.cpuset;
{$ifend}
  if a <> nil then
  begin
{$IF defined(HAVE_CPU_AFFINITY)}
      _Psched_cpu_set_vector_(@attr_cpuset)._cpuset := a.cpuset;
      CPU_ZERO(@none);
      if  not  CPU_EQUAL(@attr_cpuset, @none) then
      begin
        tp.cpuset := a.cpuset;
      end;
{$IFEND}
      stackSize := UInt32(a.stacksize);
      tp.detachState := a.detachstate;
      priority := a.param.sched_priority;
      if a.thrname <> nil then
         tp.name := strdup(a.thrname);
{$IF (THREAD_PRIORITY_LOWEST > THREAD_PRIORITY_NORMAL)}

{$ELSE}
    if Int(PTHREAD_INHERIT_SCHED) = a.inheritsched then
       priority := sp.sched_priority;

{$IFEND}
  end
  else
     stackSize := PTHREAD_STACK_MIN;


  tp.state := PThreadStateSuspended;
  tp.keys := nil;
{$IF defined (__MSVCRT__)  and not  defined (FPC)}

    threadH := THANDLE( {$if CompilerVersion <= 23} beginthread {$ELSE}_beginthreadex{$IFEND} ( nil,
              stackSize,
              @__ptw32_threadStart,
              parms,
              uint32(CREATE_SUSPENDED),
              tp.thread));
   tp.threadH := threadH;
  if threadH <> 0 then
  begin
      if a <> nil then
        begin
          __ptw32_setthreadpriority (thread, Int(SCHED_OTHER), priority);
        end;
{$IF defined(HAVE_CPU_AFFINITY)}
      SetThreadAffinityMask(tp.threadH, tp.cpuset);
{$IFEND}
      if run>0 then
          ResumeThread (threadH);

  end;
{$ELSE}
  begin

    __ptw32_mcs_lock_acquire(@tp.stateLock, @stateLock);
    threadH := THANDLE( beginthread (@__ptw32_threadStart, parms));//, stackSize));
    tp.threadH := threadH;
    if threadH = THANDLE( - 1) then
    begin
      tp.threadH := 0; threadH := 0;
    end
    else
    begin
      if  0>= run then begin

          SuspendThread (threadH);
        end;
      if a <> nil then
          __ptw32_setthreadpriority (thread, Int(SCHED_OTHER), priority);

{$IF defined(HAVE_CPU_AFFINITY)}
      SetThreadAffinityMask(tp.threadH, tp.cpuset);
{$IFEND}
    end;
    __ptw32_mcs_lock_release (@stateLock);
  end;
{$IFEND}
  if (threadH <> 0) then
     result := 0
  else
     Result := EAGAIN;


  FAIL0:
  if result <> 0 then begin
      __ptw32_threadDestroy (thread);
      tp := nil;
      if parms <> nil then
          free (parms)

  end
  else
      tid^ := thread;

{$IF defined(_UWIN)}
  if result = 0 then PostInc(pthread_count);
{$IFEND}
end;

procedure pthread_testcancel;
var
  stateLock : __ptw32_mcs_local_node_t;
  self      : pthread_t;
  sp        : __Pptw32_thread_t;
begin
  self := pthread_self ();
  sp := __Pptw32_thread_t ( self.p);
  if sp = nil then begin
      exit;
    end;

  if sp.state <> PThreadStateCancelPending then begin
      exit;
    end;
  __ptw32_mcs_lock_acquire (@sp.stateLock, @stateLock);
  if sp.cancelState <> Int(PTHREAD_CANCEL_DISABLE) then
  begin
      ResetEvent(sp.cancelEvent);
      sp.state := PThreadStateCanceling;
      sp.cancelState := Int(PTHREAD_CANCEL_DISABLE);
      __ptw32_mcs_lock_release (@stateLock);
      __ptw32_throw  (__PTW32_EPS_CANCEL);

  end;
  __ptw32_mcs_lock_release (@stateLock);
end;

function pthread_win32_getabstime_np(abstime : Ptimespec;const relative : Ptimespec):Ptimespec;
var
  sec,
  nsec        : int64;
  currSysTime : timespec;
  ft          : FILETIME;
  st          : SYSTEMTIME;
begin

{$if defined(WINCE)}
  GetSystemTime(&st);
  SystemTimeToFileTime(&st, &ft);
{$else}
  GetSystemTimeAsFileTime(&ft);
{$IFEND}
  __ptw32_filetime_to_timespec(@ft, @currSysTime);
  sec := currSysTime.tv_sec;
  nsec := currSysTime.tv_nsec;
  if nil <> relative then begin
      nsec  := nsec + relative.tv_nsec;
      if nsec >= NANOSEC_PER_SEC then
      begin
        Inc(sec);
        nsec  := nsec - NANOSEC_PER_SEC;
      end;
      sec  := sec + relative.tv_sec;
    end;
  abstime.tv_sec := time_t( sec);
  abstime.tv_nsec := long( nsec);
  Result := abstime;
end;

function pthread_rwlock_trywrlock( rwlock : Ppthread_rwlock_t):integer;
var
  result0, result1 : integer;
  rwl : pthread_rwlock_t;
begin
  if (rwlock = nil)  or  (rwlock^ = nil) then begin
      Exit(EINVAL);
    end;

  if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
  begin
      result0 := __ptw32_rwlock_check_need_init (rwlock);
      if (result0 <> 0)  and  (result0 <> EBUSY) then begin
        Exit(result);
      end;
  end;
  rwl := rwlock^;
  if rwl.nMagic <>  __PTW32_RWLOCK_MAGIC then
  begin
      Exit(EINVAL);
  end;

  result0 := pthread_mutex_trylock (@rwl.mtxExclusiveAccess);
  if  result0 <> 0 then
  begin
    Exit(result0);
  end;
  result0 := pthread_mutex_trylock (@rwl.mtxSharedAccessCompleted);
  if (result0 <> 0) then
  begin
    result1 := pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
    Exit(get_result( result1, result0));
  end;
  if rwl.nExclusiveAccessCount = 0 then
  begin
      if rwl.nCompletedSharedAccessCount > 0 then
      begin
        rwl.nSharedAccessCount  := rwl.nSharedAccessCount - rwl.nCompletedSharedAccessCount;
        rwl.nCompletedSharedAccessCount := 0;
      end;
      if rwl.nSharedAccessCount > 0 then
      begin
         result0 := pthread_mutex_unlock (@rwl.mtxSharedAccessCompleted);
         if (result0 <> 0) then
          begin
            pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
            Exit(result0);
          end;
          result0 := pthread_mutex_unlock (@rwl.mtxExclusiveAccess);
         if (result0  = 0) then
             result0 := EBUSY;

      end
      else
      begin
        rwl.nExclusiveAccessCount := 1;
      end;
  end
  else
    result0 := EBUSY;

  Result := result0;
end;

function pthread_rwlock_unlock( rwlock : Ppthread_rwlock_t):integer;
var
  result0, result1 : integer;
  rwl : pthread_rwlock_t;
begin
  if (rwlock = nil)  or  (rwlock = nil) then begin
      Exit((EINVAL));
    end;
  if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then begin

      Exit(0);
    end;
  rwl := rwlock^;
  if rwl.nMagic <>  __PTW32_RWLOCK_MAGIC then begin
      Exit(EINVAL);
    end;
  if rwl.nExclusiveAccessCount = 0 then
  begin
      result0 := pthread_mutex_lock (@rwl.mtxSharedAccessCompleted);
      if (result0 <> 0) then
      begin
        Exit(result0);
      end;
      Inc(rwl.nCompletedSharedAccessCount);
      if (rwl.nCompletedSharedAccessCount = 0)  then
      begin
        result0 := pthread_cond_signal (@(rwl.cndSharedAccessCompleted));
      end;
      result1 := pthread_mutex_unlock (@(rwl.mtxSharedAccessCompleted));
  end
  else
  begin
    Dec(rwl.nExclusiveAccessCount);
    result0 := pthread_mutex_unlock (@(rwl.mtxSharedAccessCompleted));
    result1 := pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
  end;
  Result := get_result(result0, result1);
end;

function pthread_rwlock_wrlock( rwlock : Ppthread_rwlock_t):integer;
var
  rwl : pthread_rwlock_t;
begin
  if (rwlock = nil)  or  (rwlock^ = nil) then begin
      Exit(EINVAL);
    end;

  if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
  begin
      result := __ptw32_rwlock_check_need_init (rwlock);
      if (result <> 0)  and  (result <> EBUSY) then begin
        Exit(result);
      end;
  end;
  rwl := rwlock^;
  if rwl.nMagic <>  __PTW32_RWLOCK_MAGIC then
      Exit(EINVAL);

  result := pthread_mutex_lock (@(rwl.mtxExclusiveAccess ));
  if result <> 0 then
    begin
      Exit(result);
    end;
  result := pthread_mutex_lock (@(rwl.mtxSharedAccessCompleted));
  if result <> 0 then
  begin
    pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
    Exit(result);
  end;
  if rwl.nExclusiveAccessCount = 0 then
  begin
      if rwl.nCompletedSharedAccessCount > 0 then
      begin
        rwl.nSharedAccessCount  := rwl.nSharedAccessCount - rwl.nCompletedSharedAccessCount;
        rwl.nCompletedSharedAccessCount := 0;
      end;
      if rwl.nSharedAccessCount > 0 then
      begin
        rwl.nCompletedSharedAccessCount := -rwl.nSharedAccessCount;


        pthread_cleanup_push (@__ptw32_rwlock_cancelwrwait, Pointer( rwl));
        repeat

            result := pthread_cond_wait (@(rwl.cndSharedAccessCompleted),
                @(rwl.mtxSharedAccessCompleted));

        until (result <> 0)  and  (rwl.nCompletedSharedAccessCount >= 0 );
        if (result <> 0)  then
           pthread_cleanup_pop ( 1)
        else
           pthread_cleanup_pop ( 0);

        if result = 0 then
            rwl.nSharedAccessCount := 0;

      end;
  end;
  if result = 0 then
     Inc( rwl.nExclusiveAccessCount);
end;

function pthread_rwlockattr_destroy( attr : Ppthread_rwlockattr_t):integer;
var

  rwa : pthread_rwlockattr_t;
begin
  result := 0;
  if (attr = nil)  or  (attr^ = nil) then
      result := EINVAL

  else
  begin
    rwa := attr^;
    attr^ := nil;
    free (rwa);
  end;

end;

function pthread_rwlockattr_getpshared(const attr : Ppthread_rwlockattr_t;pshared : Pinteger):integer;
begin
  if (attr <> nil)  and  (attr^ <> nil) and  (pshared <> nil) then
  begin
    pshared^ := attr^.pshared;
    result := 0;
  end
  else
  begin
    result := EINVAL;
  end;

end;

function pthread_rwlockattr_init( attr : Ppthread_rwlockattr_t):integer;
var

  rwa : pthread_rwlockattr_t;
begin
  result := 0;
  rwa := pthread_rwlockattr_t( calloc (1, sizeof ( rwa^)));
  if rwa = nil then
      result := ENOMEM

  else
  begin
    rwa.pshared := Int(PTHREAD_PROCESS_PRIVATE);
  end;
  attr^ := rwa;

end;

function pthread_rwlockattr_setpshared( attr : Ppthread_rwlockattr_t; pshared : integer):integer;
begin
  if (attr <> nil)  and  (attr^ <> nil)   and
      ((pshared = Int(PTHREAD_PROCESS_SHARED))  or
       (pshared = Int(PTHREAD_PROCESS_PRIVATE))) then
  begin
    if pshared = Int(PTHREAD_PROCESS_SHARED) then
    begin
  {$IF not defined( _POSIX_THREAD_PROCESS_SHARED )}
      result := ENOSYS;
      pshared := Int(PTHREAD_PROCESS_PRIVATE);
  {$ELSE}
      result := 0;
{$IFEND}
    end
    else
    begin
      result := 0;
    end;
    attr^.pshared := pshared;
  end
  else
  begin
    result := EINVAL;
  end;

end;

function __ptw32_new:pthread_t;
var
  t, _nil : pthread_t;
  tp : __Pptw32_thread_t;

begin
  _nil.p := nil;
  _nil.x := 0;

  //TNullable<pthread_t>.Initialize(_NULL);
  t := __ptw32_threadReusePop ();
  if nil <> t.p then begin
      tp := __Pptw32_thread_t ( t.p);
  end
  else
  begin

    tp := __Pptw32_thread_t ( calloc (1, sizeof(__ptw32_thread_t)));
    if tp = nil then
    begin
      Exit(_nil);
    end;

    t.p := tp; tp.ptHandle.p := tp;
    t.x := 0; tp.ptHandle.x := 0;
  end;

  Inc(__ptw32_threadSeqNumber);
  tp.seqNumber := (__ptw32_threadSeqNumber);
  tp.sched_priority := THREAD_PRIORITY_NORMAL;
  tp.detachState := Int(PTHREAD_CREATE_JOINABLE);
  tp.cancelState := Int(PTHREAD_CANCEL_ENABLE);
  tp.cancelType := Int(PTHREAD_CANCEL_DEFERRED);
  tp.stateLock := nil;
  tp.threadLock := nil;
  tp.robustMxListLock := nil;
  tp.robustMxList := nil;
  tp.name := nil;
{$IF defined(HAVE_CPU_AFFINITY)}
  CPU_ZERO(Pcpu_set_t(@tp.cpuset));
{$IFEND}
  tp.cancelEvent := CreateEvent (nil, LongBool(__PTW32_TRUE),
                                 LongBool(__PTW32_FALSE),
                                 nil);
  //if VarIsNull( tp.cancelEvent) then
  if Null = ( tp.cancelEvent) then
  begin
      __ptw32_threadReusePush (tp.ptHandle);
      Exit(_nil);
  end;
  Exit(t);
end;


function pthread_self():pthread_t;
var
  self,
  _nil         : pthread_t;
  _fail        : bool;
  vThreadMask,
  vProcessMask,
  vSystemMask  : DWORD_PTR;
  sp: __Pptw32_thread_t;
begin
  _nil.p := nil;
  _nil.x := 0;

{$IF defined(_UWIN)}
  if  not Assigned(__ptw32_selfThreadKey ) then
     Exit(_nil);
{$IFEND}
  sp := __Pptw32_thread_t ( pthread_getspecific (__ptw32_selfThreadKey));
  if sp <> nil then
  begin
      self := sp.ptHandle;
  end
  else
  begin
    _fail := (__PTW32_FALSE);

    self := __ptw32_new ();
    sp := __Pptw32_thread_t ( self.p);
    if sp <> nil then
    begin

      sp.implicit := 1;
      sp.detachState := Int(PTHREAD_CREATE_DETACHED);
      sp.thread := GetCurrentThreadId ();
{$IF defined(NEED_DUPLICATEHANDLE)}

      sp.threadH := GetCurrentThread ();
{$ELSE}
      if  not DuplicateHandle (GetCurrentProcess ,
                                GetCurrentThread (),
                                GetCurrentProcess (),
                                @sp.threadH,
                              0, FALSE, DUPLICATE_SAME_ACCESS) then
      begin
        _fail := bool(__PTW32_TRUE);
      end;
{$IFEND}
      if  not _fail then
      begin
{$IF defined(HAVE_CPU_AFFINITY)}

          if GetProcessAffinityMask(GetCurrentProcess(), &vProcessMask, &vSystemMask) then
          begin
            vThreadMask := SetThreadAffinityMask(sp.threadH, vProcessMask);
            if vThreadMask>0 then
            begin
                if SetThreadAffinityMask(sp.threadH, vThreadMask)>0 then
                begin
                  sp.cpuset := size_t( vThreadMask);
                end
                else
                  _fail := bool(__PTW32_TRUE);
            end
            else
              _fail := bool(__PTW32_TRUE);
          end
          else
            _fail := bool(__PTW32_TRUE);
{$IFEND}
          sp.sched_priority := GetThreadPriority (sp.threadH);
          pthread_setspecific (__ptw32_selfThreadKey, sp);
      end;
    end;

    if _fail then
    begin

      __ptw32_threadReusePush (self);

      Exit(_nil);
    end
    else
    begin
       sp.state := PThreadStateRunning;
    end;
  end;
  Result := (self);
end;

function CPU_ISSET(cpu : integer;const setptr : Pcpu_set_t): Boolean;
Begin
   Result := _sched_affinitycpuisset(cpu,setptr);
end;

procedure CPU_CLR(cpu : integer; setptr : Pcpu_set_t);
begin
   _sched_affinitycpuclr(cpu, setptr);
end;

procedure CPU_OR(pdestset : Pcpu_set_t;const psrcset1 : Pcpu_set_t; const psrcset2 : Pcpu_set_t);
begin
  _sched_affinitycpuor(pdestset,psrcset1, psrcset2);
end;

procedure CPU_XOR(pdestset : Pcpu_set_t;const psrcset1 : Pcpu_set_t;const psrcset2 : Pcpu_set_t) ;
begin
   _sched_affinitycpuxor(pdestset, psrcset1, psrcset2);
end;

procedure CPU_SET(cpu : integer; setptr : Pcpu_set_t);
begin
  _sched_affinitycpuset(cpu,setptr);
end;

procedure CPU_AND(destsetptr, srcset1ptr, srcset2ptr: Pointer);
begin
  _sched_affinitycpuand(destsetptr, srcset1ptr, srcset2ptr);
end;

function sched_getaffinity( pid : pid_t; cpusetsize : NativeUInt; &set : Pcpu_set_t):integer;
var
  vProcessMask,
  vSystemMask  : DWORD_PTR;
  h            : THANDLE;
  targetPid    : Integer;

begin
  targetPid := int(size_t( pid));
  result := 0;
  if nil = &set then begin
    result := EFAULT;
    end
  else
    begin
{$IF not  defined(NEED_PROCESS_AFFINITY_MASK)}
    if 0 = targetPid then begin
      targetPid := int( GetCurrentProcessId );
    end;
    h := OpenProcess (PROCESS_QUERY_INFORMATION,  LongBool(__PTW32_FALSE), DWORD( targetPid));
    //if VarIsNull( h) then
    if Null = ( h) then
    begin
      if ($FF and ERROR_ACCESS_DENIED) = GetLastError() then
         result := EPERM
      else
         Result := ESRCH;
    end
    else
    begin
    if GetProcessAffinityMask (h, &vProcessMask, &vSystemMask  )  then
      begin
        _Psched_cpu_set_vector_(&set)._cpuset := vProcessMask;
      end
      else
      begin
         result := EAGAIN;
      end;
    end;
    CloseHandle(h);
{$ELSE}
   _Psched_cpu_set_vector_(&set)._cpuset := size_t($1);
{$IFEND}
    end;
  if result <> 0 then begin
     __PTW32_SET_ERRNO(result);
    Exit(-1);
    end
  else

    Exit(0);

end;

function pthread_setaffinity_np(thread : pthread_t; cpusetsize : NativeUInt;const cpuset : Pcpu_set_t):integer;
var

  tp            : __Pptw32_thread_t;
  node          : __ptw32_mcs_local_node_t;
  processCpuset,
  newMask       : cpu_set_t;
begin
{$IF not  defined(HAVE_CPU_AFFINITY)}
  Exit(ENOSYS);
{$ELSE}
  result := 0;
  __ptw32_mcs_lock_acquire (@__ptw32_thread_reuse_lock, @node);
  tp := __Pptw32_thread_t ( thread.p);
  if (nil = tp)  or  (thread.x <> tp.ptHandle.x)  or  (VarIsNull( tp.threadH)) then
  begin
    result := ESRCH;
  end
  else
  begin
    if Assigned(cpuset) then
    begin
      if sched_getaffinity(0, sizeof(cpu_set_t), @processCpuset)>0 then
      begin
        result := __PTW32_GET_ERRNO();
      end
      else
      begin

        CPU_AND(@newMask, @processCpuset, cpuset);
        if _Psched_cpu_set_vector_( @newMask)._cpuset>0 then
        begin
          if SetThreadAffinityMask (tp.threadH, _Psched_cpu_set_vector_(@newMask)._cpuset)>0 then
          begin

            tp.cpuset := _Psched_cpu_set_vector_(@newMask)._cpuset;
          end
          else
          begin
            result := EAGAIN;
          end;
        end
        else
        begin
          result := EINVAL;
        end;
      end;
    end
    else
    begin
      result := EFAULT;
    end;
  end;
  __ptw32_mcs_lock_release (@node);
  Exit(result);
{$IFEND}
end;


function pthread_getaffinity_np( thread : pthread_t; cpusetsize : NativeUInt; cpuset : Pcpu_set_t):integer;
var

  tp          : __Pptw32_thread_t;
  node        : __ptw32_mcs_local_node_t;
  vThreadMask : DWORD_PTR;
begin
{$IF not  defined(HAVE_CPU_AFFINITY)}
  Exit(ENOSYS);
{$ELSE} result := 0;
  __ptw32_mcs_lock_acquire(@__ptw32_thread_reuse_lock, @node);
  tp := __Pptw32_thread_t ( thread.p);
  if (nil = tp)  or  (thread.x <> tp.ptHandle.x)  or  (VarIsNull( tp.threadH)) then begin
    result := ESRCH;
    end
  else
  begin
    if Assigned(cpuset) then
    begin
      if tp.cpuset>0 then
      begin

          vThreadMask := SetThreadAffinityMask(tp.threadH, tp.cpuset);
          if (vThreadMask >0) and  (vThreadMask <> tp.cpuset) then
          begin
             SetThreadAffinityMask(tp.threadH, vThreadMask);
            tp.cpuset := vThreadMask;
          end;
      end;
      _Psched_cpu_set_vector_(cpuset)._cpuset := tp.cpuset;
    end
    else
    begin
      result := EFAULT;
    end;
  end;
  __ptw32_mcs_lock_release(@node);
  Exit(result);
{$IFEND}
end;

function pthread_setcancelstate( state : integer; oldstate : pinteger):integer;
var
  stateLock : __ptw32_mcs_local_node_t;
  sp        : __Pptw32_thread_t;
  self      : pthread_t;
begin
  result := 0;
  self := pthread_self ();
  sp := __Pptw32_thread_t ( self.p);
  if (sp = nil)
       or  ( (state <> Int(PTHREAD_CANCEL_ENABLE))  and  (state <> Int(PTHREAD_CANCEL_DISABLE))) then
  begin
    Exit(EINVAL);
  end;

  __ptw32_mcs_lock_acquire (@sp.stateLock, @stateLock);
  if oldstate <> nil then begin
    oldstate^ := sp.cancelState;
  end;
  sp.cancelState := state;

  if (state = Int(PTHREAD_CANCEL_ENABLE))
       and  (sp.cancelType = Int(PTHREAD_CANCEL_ASYNCHRONOUS))
       and  (WaitForSingleObject (sp.cancelEvent, 0 ) = WAIT_OBJECT_0 )then
  begin
    sp.state := PThreadStateCanceling;
    sp.cancelState := Int(PTHREAD_CANCEL_DISABLE);
    ResetEvent (sp.cancelEvent);
    __ptw32_mcs_lock_release (@stateLock);
    __ptw32_throw  (__PTW32_EPS_CANCEL);

  end;
  __ptw32_mcs_lock_release (@stateLock);
  Exit((result));
end;

function pthread_setcanceltype( &type : integer; oldtype : Pinteger):integer;
var
  stateLock : __ptw32_mcs_local_node_t;

  self      : pthread_t;
  sp        : __Pptw32_thread_t;
begin
  result := 0;
  self := pthread_self ();
  sp := __Pptw32_thread_t ( self.p);
  if (sp = nil)or
        ( (&type <> Int(PTHREAD_CANCEL_DEFERRED)) and
          (&type <> Int(PTHREAD_CANCEL_ASYNCHRONOUS))) then
    begin
      Exit(EINVAL);
    end;

  __ptw32_mcs_lock_acquire (@sp.stateLock, @stateLock);
  if oldtype <> nil then begin
      oldtype^ := sp.cancelType;
    end;
  sp.cancelType := &type;

  if (sp.cancelState = Int(PTHREAD_CANCEL_ENABLE))   and
      (&type = Int(PTHREAD_CANCEL_ASYNCHRONOUS))  and
      (WaitForSingleObject (sp.cancelEvent, 0)  = WAIT_OBJECT_0)  then
    begin
      sp.state := PThreadStateCanceling;
      sp.cancelState := Int(PTHREAD_CANCEL_DISABLE);
      ResetEvent (sp.cancelEvent);
      __ptw32_mcs_lock_release (@stateLock);
      __ptw32_throw  (__PTW32_EPS_CANCEL);

    end;
  __ptw32_mcs_lock_release (@stateLock);
  Exit((result));
end;

function pthread_setconcurrency( level : integer):integer;
begin
  if level < 0 then begin
      Exit(EINVAL);
  end
  else
  begin
    __ptw32_concurrency := level;
    Exit(0);
  end;
end;

{$if defined(_MSC_VER)}
const MS_VC_EXCEPTION = $406D1388 ;
procedure SetThreadName( dwThreadID : DWORD; threadName : Pchar);
var
  info : THREADNAME_INFO;
begin
  info.dwType := $1000;
  info.szName := threadName;
  info.dwThreadID := dwThreadID;
  info.dwFlags := 0;
  __try
  begin
    RaiseException( MS_VC_EXCEPTION, 0, sizeof(info)/sizeof(ULONG_PTR), (ULONG_PTR*)&info );
  end;
  __except(EXCEPTION_EXECUTE_HANDLER)
  begin
  end;
end;
{$IFEND}

{$if defined (__PTW32_COMPATIBILITY_BSD) or defined (__PTW32_COMPATIBILITY_TRU64)}
function pthread_setname_np(thr : pthread_t;const name : Pchar; arg : Pointer):integer;
var
  threadLock    : __ptw32_mcs_local_node_t;
  len,
  result        : integer;
  tmpbuf        : array[0..(PTHREAD_MAX_NAMELEN_NP)-1] of byte;
  newname,
  oldname       : Pchar;
  tp            : __Pptw32_thread_t;
  Win32ThreadID : DWORD;
begin
{$IF defined(_MSC_VER)}
{$IFEND}
  /
  result := pthread_kill (thr, 0);
  if 0 <> result then begin
      Exit(result);
    end;
  /
  len := snprintf(tmpbuf, PTHREAD_MAX_NAMELEN_NP-1, name, arg);
  tmpbuf[PTHREAD_MAX_NAMELEN_NP-1] := #0;
  if len < 0 then begin
      Exit(EINVAL);
    end;
  newname := _strdup(tmpbuf);
{$IF defined(_MSC_VER)}
  Win32ThreadID := pthread_getw32threadid_np (thr);
  if Win32ThreadID then begin
      SetThreadName(Win32ThreadID, newname);
    end;
{$IFEND}
  tp := (__ptw32_thread_t *) thr.p;
  __ptw32_mcs_lock_acquire (&tp.threadLock, &threadLock);
  oldname := tp.name;
  tp.name := newname;
  if oldname then begin
      free(oldname);
    end;
  __ptw32_mcs_lock_release (&threadLock);
  Result := 0;
end;

{$ELSE}
function pthread_setname_np(thr : pthread_t;const name : Pchar):integer;
var
  threadLock    : __ptw32_mcs_local_node_t;
  newname, oldname: PChar;

  tp: __Pptw32_thread_t;
  {$IF defined(_MSC_VER)}
  Win32ThreadID : DWORD;
{$IFEND}
begin

  result := pthread_kill (thr, 0);
  if 0 <> result then begin
      Exit(result);
    end;
  newname := strdup(name);
{$IF defined(_MSC_VER)}
  Win32ThreadID := pthread_getw32threadid_np (thr);
  if Win32ThreadID then begin
      SetThreadName(Win32ThreadID, newname);
    end;
{$IFEND}
  tp := __Pptw32_thread_t ( thr.p);
  __ptw32_mcs_lock_acquire (@tp.threadLock, @threadLock);
  oldname := tp.name;
  tp.name := newname;
  if Assigned(oldname) then begin
      free(oldname);
    end;
  __ptw32_mcs_lock_release (@threadLock);
  Result := 0;
end;
{$IFEND}

function pthread_setschedparam(thread : pthread_t; policy : integer;const param : Psched_param):integer;
begin
  result := pthread_kill (thread, 0);
  if 0 <> result then begin
      Exit(result);
    end;

  if (policy < Int(SCHED_MIN))  or  (policy > Int(SCHED_MAX)) then begin
      Exit(EINVAL);
    end;

  if policy <> Int(SCHED_OTHER) then begin
      Exit(ENOTSUP);
    end;
  Result := (__ptw32_setthreadpriority (thread, policy, param.sched_priority));
end;


function __ptw32_setthreadpriority( thread : pthread_t; policy, priority : integer):integer;
var
  prio       : integer;
  threadLock : __ptw32_mcs_local_node_t;

  tp         : __Pptw32_thread_t;
begin
  result := 0;
  tp := __Pptw32_thread_t ( thread.p);
  prio := priority;

  if (prio < sched_get_priority_min (policy ))  or
     ( prio > sched_get_priority_max (policy)) then
    begin
      Exit(EINVAL);
    end;
{$IF (THREAD_PRIORITY_LOWEST > THREAD_PRIORITY_NORMAL)}
//
{$ELSE }
  if (THREAD_PRIORITY_IDLE < prio)  and  (THREAD_PRIORITY_LOWEST > prio) then
  begin
      prio := THREAD_PRIORITY_LOWEST;
  end
  else
  if (THREAD_PRIORITY_TIME_CRITICAL > prio)
      and  (THREAD_PRIORITY_HIGHEST < prio) then
  begin
    prio := THREAD_PRIORITY_HIGHEST;
  end;
{$IFEND}
  __ptw32_mcs_lock_acquire (@tp.threadLock, @threadLock);

  if LongBool(0) = SetThreadPriority (tp.threadH, prio) then
    begin
      result := EINVAL;
    end
  else
    begin

      tp.sched_priority := priority;
    end;
  __ptw32_mcs_lock_release (@threadLock);
  Result := result;
end;

function __ptw32_tkAssocCreate( sp : __Pptw32_thread_t; key : pthread_key_t):integer;
var
  assoc : PThreadKeyAssoc;
begin

  assoc := PThreadKeyAssoc ( calloc (1, sizeof ( assoc^)));
  if assoc = nil then begin
      Exit(ENOMEM);
    end;
  assoc.thread := sp;
  assoc.key := key;

  assoc.prevThread := nil;
  assoc.nextThread := PThreadKeyAssoc ( key.threads);
  if assoc.nextThread <> nil then begin
      assoc.nextThread.prevThread := assoc;
    end;
  key.threads := Pointer( assoc);

  assoc.prevKey := nil;
  assoc.nextKey := PThreadKeyAssoc ( sp.keys);
  if assoc.nextKey <> nil then begin
      assoc.nextKey.prevKey := assoc;
    end;
  sp.keys := Pointer( assoc);
  Exit((0));
end;

function pthread_setspecific(key : pthread_key_t;const value : Pointer):integer;
var
  self       : pthread_t;
  sp         : __Pptw32_thread_t;
  keyLock,
  threadLock : __ptw32_mcs_local_node_t;
  assoc      : PThreadKeyAssoc;
begin
  result := 0;
  if key <> __ptw32_selfThreadKey then
  begin

      self := pthread_self ();
      if self.p = nil then begin
        Exit(ENOENT);
      end;
  end
  else
  begin

    sp := __Pptw32_thread_t ( pthread_getspecific (__ptw32_selfThreadKey));
    if sp = nil then
    begin
      if value = nil then

          Exit(ENOENT);

        self := Ppthread_t ( value)^;
    end
    else

       self := sp.ptHandle;

  end;

  result := 0;
  if key <> nil then
  begin
      if (self.p <> nil)  and  (key._destructor <> nil)  and  (value <> nil) then
      begin
          sp := __Pptw32_thread_t ( self.p);

          __ptw32_mcs_lock_acquire(@(key.keyLock), @keyLock);
          __ptw32_mcs_lock_acquire(@(sp.threadLock), @threadLock);
          assoc := PThreadKeyAssoc ( sp.keys);

          while assoc <> nil do
          begin
            if assoc.key = key then
                break;

            assoc := assoc.nextKey;
          end;

          if assoc = nil then
              result := __ptw32_tkAssocCreate (sp, key);

          __ptw32_mcs_lock_release(@threadLock);
          __ptw32_mcs_lock_release(@keyLock);
      end;

      if result = 0 then
      begin
        if  not TlsSetValue (key.key, LPVOID( value)) then
            result := EAGAIN;

      end;
  end;

end;

function pthread_spin_destroy( lock : Ppthread_spinlock_t):integer;
var
  s : pthread_spinlock_t;

  node : __ptw32_mcs_local_node_t;
begin
  result := 0;
  if (lock = nil)  or  (lock^ = nil) then begin
      Exit(EINVAL);
    end;

  s := lock^;
  if s  <> PTHREAD_SPINLOCK_INITIALIZER then
  begin
      if s.interlock =  __PTW32_SPIN_USE_MUTEX then
      begin
        result := pthread_mutex_destroy (@(s.u.mutex));
      end
      else
      if  __PTW32_INTERLOCKED_LONG(  __PTW32_SPIN_UNLOCKED) <>
          __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG  (__PTW32_INTERLOCKED_LONGPTR( @s.interlock)^,
                __PTW32_INTERLOCKED_LONG(  __PTW32_SPIN_INVALID),
                __PTW32_INTERLOCKED_LONG ( __PTW32_SPIN_UNLOCKED)) then
      begin
        result := EINVAL;
      end;
      if 0 = result then
      begin

        lock^ := nil;
        free (s);
      end;
  end
  else
  begin

    __ptw32_mcs_lock_acquire(@__ptw32_spinlock_test_init_lock, @node);

    if lock^ = PTHREAD_SPINLOCK_INITIALIZER then
    begin

      lock^ := nil;
    end
    else
    begin

      result := EBUSY;
    end;
     __ptw32_mcs_lock_release(@node);
  end;

end;

function pthread_spin_init( lock : Ppthread_spinlock_t; pshared : integer):integer;
var
  s : pthread_spinlock_t;
  cpus : integer;
  ma : pthread_mutexattr_t;
begin
  cpus := 0;
  result := 0;
  if lock = nil then begin
      Exit(EINVAL);
    end;
  if 0 <> __ptw32_getprocessors (@cpus) then
    begin
      cpus := 1;
    end;
  if cpus > 1 then
  begin
      if pshared = Int(PTHREAD_PROCESS_SHARED) then
      begin

      {$IF _POSIX_THREAD_PROCESS_SHARED >= 0}

         raise Exception.Create('Process shared spin locks are not supported yet.');
      {$ELSE}
         Exit(ENOSYS);
      {$IFEND}
      end;
  end;
  s := pthread_spinlock_t( calloc (1, sizeof ( s^)));
  if s = nil then begin
      Exit(ENOMEM);
    end;
  if cpus > 1 then begin
      s.u.cpus := cpus;
      s.interlock := __PTW32_SPIN_UNLOCKED;
  end
  else
  begin
    result := pthread_mutexattr_init (@ma);
    if 0 = result then
    begin
      ma.pshared := pshared;
      result := pthread_mutex_init (@(s.u.mutex), @ma);
      if 0 = result then begin
          s.interlock := __PTW32_SPIN_USE_MUTEX;
        end;
    end;
    pthread_mutexattr_destroy (@ma);
  end;
  if 0 = result then
      lock^ := s

  else
  begin
    free (s);
    lock^ := nil;
  end;
  Result := (result);
end;

function __ptw32_spinlock_check_need_init( lock : Ppthread_spinlock_t):integer;
var

  node : __ptw32_mcs_local_node_t;
begin
  result := 0;

  __ptw32_mcs_lock_acquire(@__ptw32_spinlock_test_init_lock, @node);

  if lock^ = PTHREAD_SPINLOCK_INITIALIZER then begin
    result := pthread_spin_init (lock, Int(PTHREAD_PROCESS_PRIVATE));
  end
  else
  if ( lock^ = nil) then
  begin

    result := EINVAL;
  end;
  __ptw32_mcs_lock_release(@node);

end;

function pthread_spin_lock( lock : Ppthread_spinlock_t):integer;
var
  s : pthread_spinlock_t;

begin
  if (nil = lock)  or  (nil = lock^) then begin
      Exit((EINVAL));
    end;
  if lock^ = PTHREAD_SPINLOCK_INITIALIZER then
  begin
      result := __ptw32_spinlock_check_need_init (lock);
      if result <> 0 then
      begin
        Exit((result));
      end;
  end;
  s := lock^;
  while __PTW32_INTERLOCKED_LONG (__PTW32_SPIN_LOCKED) =
    __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG  (__PTW32_INTERLOCKED_LONGPTR( @s.interlock)^,
                     __PTW32_INTERLOCKED_LONG(  __PTW32_SPIN_LOCKED),
                     __PTW32_INTERLOCKED_LONG(  __PTW32_SPIN_UNLOCKED)) do
    begin
    end;
  if s.interlock =  __PTW32_SPIN_LOCKED then begin
    Exit(0);
  end
  else
  if (s.interlock =  __PTW32_SPIN_USE_MUTEX) then
    begin
      Exit(pthread_mutex_lock (@(s.u.mutex)));
    end;
  Result := EINVAL;
end;

function pthread_spin_unlock( lock : Ppthread_spinlock_t):integer;
var
  s : pthread_spinlock_t;
begin
  if (nil = lock)  or  (nil = lock^) then begin
      Exit((EINVAL));
    end;
  s := lock^;
  if s = PTHREAD_SPINLOCK_INITIALIZER then begin
      Exit(EPERM);
    end;
  case (long(
     __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG  (__PTW32_INTERLOCKED_LONGPTR( @s.interlock)^,
                 __PTW32_INTERLOCKED_LONG(  __PTW32_SPIN_UNLOCKED),
                 __PTW32_INTERLOCKED_LONG(  __PTW32_SPIN_LOCKED)))) of

    __PTW32_SPIN_LOCKED,
    __PTW32_SPIN_UNLOCKED:
      Exit(0);
    __PTW32_SPIN_USE_MUTEX:
      Exit(pthread_mutex_unlock (@(s.u.mutex)));
  end;
  Result := EINVAL;
end;

function pthread_spin_trylock( lock : Ppthread_spinlock_t):integer;
var
  s : pthread_spinlock_t;

begin
  if (nil = lock)  or  (nil = lock^) then begin
      Exit((EINVAL));
    end;
  if lock^ = PTHREAD_SPINLOCK_INITIALIZER then
  begin
      result := __ptw32_spinlock_check_need_init (lock);
      if result <> 0 then
      begin
        Exit((result));
      end;
  end;
  s := lock^;
  case (long(
     __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG  (__PTW32_INTERLOCKED_LONGPTR(@s.interlock)^,
                      __PTW32_INTERLOCKED_LONG(  __PTW32_SPIN_LOCKED),
                      __PTW32_INTERLOCKED_LONG(  __PTW32_SPIN_UNLOCKED)))) of

    __PTW32_SPIN_UNLOCKED:
      Exit(0);
    __PTW32_SPIN_LOCKED:
      Exit(EBUSY);
    __PTW32_SPIN_USE_MUTEX:
      Exit(pthread_mutex_trylock (@(s.u.mutex)));
  end;
  Result := EINVAL;
end;

procedure __ptw32_processTerminate;
var
  tp, tpNext : __Pptw32_thread_t;
  node : __ptw32_mcs_local_node_t;
begin
  if __ptw32_processInitialized>0 then
  begin
      if __ptw32_selfThreadKey <> nil then
      begin

        pthread_key_delete (__ptw32_selfThreadKey);
        __ptw32_selfThreadKey := nil;
      end;
      if __ptw32_cleanupKey <> nil then
      begin

        pthread_key_delete (__ptw32_cleanupKey);
        __ptw32_cleanupKey := nil;
      end;
      __ptw32_mcs_lock_acquire(@__ptw32_thread_reuse_lock, @node);
      tp := __ptw32_threadReuseTop;
      while tp <>  __PTW32_THREAD_REUSE_EMPTY do
      begin
        tpNext := tp.prevReuse;
        free (tp);
        tp := tpNext;
      end;
      __ptw32_mcs_lock_release(@node);
      __ptw32_processInitialized := Int(__PTW32_FALSE);
    end;
end;

function __ptw32_processInitialize:integer;
begin
  if __ptw32_processInitialized >0 then begin
      Exit(Int(__PTW32_TRUE));
    end;

  __ptw32_threadReuseTop := __PTW32_THREAD_REUSE_EMPTY;
  __ptw32_threadReuseBottom := __PTW32_THREAD_REUSE_EMPTY;
  __ptw32_selfThreadKey := nil;
  __ptw32_cleanupKey := nil;
  __ptw32_cond_list_head := nil;
  __ptw32_cond_list_tail := nil;
  __ptw32_concurrency := 0;

  __ptw32_features := 0;

  __ptw32_threadSeqNumber := 0;

  __ptw32_register_cancellation := nil;

  __ptw32_thread_reuse_lock := nil;

  __ptw32_mutex_test_init_lock := nil;

  __ptw32_cond_test_init_lock := nil;

  __ptw32_rwlock_test_init_lock := nil;

  __ptw32_spinlock_test_init_lock := nil;

  __ptw32_cond_list_lock := nil;
  {$IF defined(_UWIN)}

  pthread_count := 0;
  {$IFEND}
  __ptw32_processInitialized := Int(__PTW32_TRUE);

  if (pthread_key_create (@__ptw32_selfThreadKey, nil) <> 0 )   or
     (pthread_key_create (@__ptw32_cleanupKey, nil) <> 0) then
    begin
      __ptw32_processTerminate ();
    end;
  Exit((__ptw32_processInitialized));
end;
(*
function wcsncat_s(strDest : Pwchar_t; destMax : size_t;const strSrc : Pwchar_t; count : size_t):errno_t;
begin
    if (destMax = 0)  or  (destMax > SECUREC_WCHAR_STRING_MAX_LEN) then
    begin
        SECUREC_ERROR_INVALID_RANGE('wcsncat_s');
        Exit(ERANGE);
    end;
    if (strDest = nil)  or  (strSrc = nil) then
    begin
        SECUREC_ERROR_INVALID_PARAMTER('wcsncat_s');
        if strDest <> nil then
        begin
            strDest[0] := #0;
            Exit(EINVAL_AND_RESET);
        end;
        Exit(EINVAL);
    end;
    if count > SECUREC_WCHAR_STRING_MAX_LEN then
    begin
{$IFDEF SECUREC_COMPATIBLE_WIN_FORMAT}
        if count = (size_t(-1)) then
        begin

            Exit(SecDoCatLimitW(strDest, destMax, strSrc, destMax));
        end;
{$ENDIF}
        strDest[0] := #0;
        SECUREC_ERROR_INVALID_RANGE('wcsncat_s');
        Exit(ERANGE_AND_RESET);
    end;
    Result := SecDoCatLimitW(strDest, destMax, strSrc, count);
end;
*)

function pthread_win32_process_attach_np: Integer;
var
  QuserExDLLPathBuf : array[0..1023] of WCHAR;
  queue_user_apc_ex_init: Pqueue_user_apc_ex_init;
begin
  result := int(TRUE);
  result := __ptw32_processInitialize ();
{$IF defined(_UWIN)}
  PostInc(pthread_count);
{$IFEND}
{$IF defined(__GNUC__)}
  __ptw32_features := 0;
{$ELSE }
  __ptw32_features := Int(__PTW32_SYSTEM_INTERLOCKED_COMPARE_EXCHANGE);
{$IFEND}

{$IF defined(__GNUC__)  or  defined (__PTW32_CONFIG_MSVC7)}
  if GetSystemDirectory(@QuserExDLLPathBuf, sizeof(QuserExDLLPathBuf))>0 then
  begin
    strncat(@QuserExDLLPathBuf,
                   '\QUSEREX.DLL',
                   sizeof(QuserExDLLPathBuf) - Length(QuserExDLLPathBuf) - 1);
    __ptw32_h_quserex := LoadLibrary(@QuserExDLLPathBuf);
  end;
{$ELSE }
    {$if  not  defined(WINCE)}
      if (GetSystemDirectory(QuserExDLLPathBuf, sizeof(QuserExDLLPathBuf)  div sizeof(WCHAR))>0 )  and
         ( 0 = _tcsncat_s(QuserExDLLPathBuf, _countof(QuserExDLLPathBuf), TEXT('\QUSEREX.DLL'), 12)) then
        begin
          __ptw32_h_quserex := LoadLibrary(QuserExDLLPathBuf);
        end;
    {$IFEND}
{$IFEND}
  //if not VarIsNull( __ptw32_h_quserex) then
  if Null <> ( __ptw32_h_quserex) then
  begin
      __ptw32_register_cancellation := //(DWORD ( *)(PAPCFUNC, HANDLE, DWORD))
{$IF defined(NEED_UNICODE_CONSTS)}
    GetProcAddress (__ptw32_h_quserex, (const TCHAR *) TEXT ('QueueUserAPCEx'));
{$ELSE}
    GetProcAddress (__ptw32_h_quserex, ( 'QueueUserAPCEx'));
{$IFEND}
  end;
  if nil = __ptw32_register_cancellation then
  begin
      __ptw32_register_cancellation := @__ptw32_Registercancellation;
      if Null <> ( __ptw32_h_quserex) then
      begin
        FreeLibrary (__ptw32_h_quserex);
      end;
      __ptw32_h_quserex := 0;
  end
  else
  begin


    queue_user_apc_ex_init :=
{$IF defined(NEED_UNICODE_CONSTS)}
    GetProcAddress (__ptw32_h_quserex, (const TCHAR *) TEXT ('QueueUserAPCEx_Init'));
{$ELSE}
    GetProcAddress (__ptw32_h_quserex, 'QueueUserAPCEx_Init');
{$IFEND}
    if (queue_user_apc_ex_init = nil)  or   (not Assigned(queue_user_apc_ex_init) ) then
    begin
      __ptw32_register_cancellation := @__ptw32_Registercancellation;
      FreeLibrary (__ptw32_h_quserex);
      __ptw32_h_quserex := 0;
    end;
  end;
  if (__ptw32_h_quserex>0 ) then
  begin
      __ptw32_features  := __ptw32_features  or Int(__PTW32_ALERTABLE_ASYNC_CANCEL);
  end;

end;


function pthread_win32_process_detach_np:Boolean;
var
  sp: __Pptw32_thread_t;
  queue_user_apc_ex_fini: Pqueue_user_apc_ex_fini;
begin
  if __ptw32_processInitialized>0 then
  begin
      sp := __Pptw32_thread_t( pthread_getspecific (__ptw32_selfThreadKey));
      if sp <> nil then
      begin

        if sp.detachState = Int(PTHREAD_CREATE_DETACHED) then
          begin
            __ptw32_threadDestroy (sp.ptHandle);
            if Assigned(__ptw32_selfThreadKey) then
            begin
              TlsSetValue (__ptw32_selfThreadKey.key, nil);
            end;
          end;
      end;

      __ptw32_processTerminate ();
      if __ptw32_h_quserex > 0 then
      begin


        queue_user_apc_ex_fini :=
        {$IF defined(NEED_UNICODE_CONSTS)}
              GetProcAddress (__ptw32_h_quserex,
                  (const TCHAR *) TEXT ('QueueUserAPCEx_Fini'));
        {$ELSE}
              GetProcAddress (__ptw32_h_quserex, 'QueueUserAPCEx_Fini');
        {$IFEND}
            if queue_user_apc_ex_fini <> nil then
            begin
                queue_user_apc_ex_fini^ ();
            end;
            FreeLibrary (__ptw32_h_quserex);
      end;
  end;
  Result := TRUE;
end;


function pthread_win32_thread_attach_np:Boolean;
begin
  Result := TRUE;
end;

procedure __ptw32_callUserDestroyRoutines( thread : pthread_t);
var
  assoc           : PThreadKeyAssoc;
  threadLock,
  keyLock         : __ptw32_mcs_local_node_t;
  assocsRemaining,
  iterations      : integer;
  k               : pthread_key_t;
  sp              : __Pptw32_thread_t;
  _destructor     : Pdestructor;
  value           : Pointer;
  I               : Integer;
begin
  if thread.p <> nil then
  begin
      iterations := 0;
      sp := __Pptw32_thread_t ( thread.p);

    
    repeat
          assocsRemaining := 0;
          Inc(iterations);
          __ptw32_mcs_lock_acquire(@(sp.threadLock), @threadLock);

          sp.nextAssoc := sp.keys;
          __ptw32_mcs_lock_release(@threadLock);
          for I := 0 to 1000 do
               
          begin
              

              __ptw32_mcs_lock_acquire(@(sp.threadLock), @threadLock);
              assoc := PThreadKeyAssoc(sp.nextAssoc);
              if assoc = nil then
              begin

                __ptw32_mcs_lock_release(@threadLock);
                break;
              end
              else
              begin

                if __ptw32_mcs_lock_try_acquire(@assoc.key.keyLock  , @keyLock) = EBUSY then
                  begin
                    __ptw32_mcs_lock_release(@threadLock);
                    Sleep(0);

                    continue;
                  end;
              end;

              sp.nextAssoc := assoc.nextKey;

              k := assoc.key;
              _destructor := k._destructor;
              value := TlsGetValue(k.key);
              TlsSetValue (k.key, nil);
              if (value <> nil)  and  (iterations <= PTHREAD_DESTRUCTOR_ITERATIONS) then 
              begin
            
                __ptw32_mcs_lock_release(@threadLock);
                __ptw32_mcs_lock_release(@keyLock);
                Inc(assocsRemaining);
                {$IF defined(__cplusplus)}
                      try
             
               
                          _destructor (value);
            
                      except on E: exception do
                      
                          terminate ();
                      end;
                {$ELSE }
            
                   _destructor^(value);
                {$IFEND}
              end
              else
              begin
              
                __ptw32_tkAssocDestroy (assoc);
                __ptw32_mcs_lock_release(@threadLock);
                __ptw32_mcs_lock_release(@keyLock);
              end;
         end;
    until assocsRemaining <=0;
  end;
end;


function pthread_win32_thread_detach_np:Boolean;
var
  stateLock : __ptw32_mcs_local_node_t;
  mx        : pthread_mutex_t;
  sp        : __Pptw32_thread_t;
begin
  if __ptw32_processInitialized>0 then
  begin

      sp := __Pptw32_thread_t ( pthread_getspecific (__ptw32_selfThreadKey));
      if sp <> nil then
      begin
          __ptw32_callUserDestroyRoutines (sp.ptHandle);
          __ptw32_mcs_lock_acquire (@sp.stateLock, @stateLock);
          sp.state := PThreadStateLast;

          __ptw32_mcs_lock_release (@stateLock);

          while sp.robustMxList <> nil do
            begin
              mx := sp.robustMxList.mx;
              __ptw32_robust_mutex_remove(@mx, sp);
               __PTW32_INTERLOCKED_EXCHANGE_LONG(
                        __PTW32_INTERLOCKED_LONGPTR(@mx.robustNode.stateInconsistent)^,
                        __PTW32_INTERLOCKED_LONG(-1));

              SetEvent(mx.event);
            end;
          if sp.detachState = Int(PTHREAD_CREATE_DETACHED) then
          begin
              __ptw32_threadDestroy (sp.ptHandle);
              if Assigned(__ptw32_selfThreadKey) then
                 TlsSetValue (__ptw32_selfThreadKey.key, nil);

          end;
      end;
  end;
  Result := TRUE;
end;


function pthread_win32_test_features_np( feature_mask : integer):Boolean;
begin
  Result := ((__ptw32_features and feature_mask) = feature_mask);
end;

function pthread_tryjoin_np( thread : pthread_t; value_ptr : PPointer):integer;
var
  self : pthread_t;
  tp : __Pptw32_thread_t;
  node : __ptw32_mcs_local_node_t;
begin
  tp := __Pptw32_thread_t ( thread.p);
  __ptw32_mcs_lock_acquire(@__ptw32_thread_reuse_lock, @node);
  if (nil = tp) or  (thread.x <> tp.ptHandle.x) then begin
      result := ESRCH;
  end
  else
  if (Int(PTHREAD_CREATE_DETACHED) = tp.detachState) then
  begin
    result := EINVAL;
  end
  else
  begin
    result := 0;
  end;
  __ptw32_mcs_lock_release(@node);
  if result = 0 then
  begin

      self := pthread_self();
      if nil = self.p then begin
        result := ENOENT;
      end
      else
      if (pthread_equal (self, thread)) then
      begin
        result := EDEADLK;
      end
      else
        begin

          result := pthreadCancelableTimedWait (tp.threadH, 0);
          if 0 = result then
          begin
              if value_ptr <> nil then
                begin
                  value_ptr^ := tp.exitStatus;
                end;

              result := pthread_detach (thread);
          end
          else
          if (ETIMEDOUT = result) then
          begin
            result := EBUSY;
          end
          else
          begin
            result := ESRCH;
          end;
        end;
    end;
  Exit((result));
end;

function pthread_timedjoin_np(thread : pthread_t; value_ptr : PPointer;const abstime : Ptimespec):integer;
var

  self         : pthread_t;
  milliseconds : DWORD;
  tp           : __Pptw32_thread_t;
  node         : __ptw32_mcs_local_node_t;
begin
  tp := __Pptw32_thread_t ( thread.p);
  if abstime = nil then begin
      milliseconds := INFINITE;
  end
  else
  begin

    milliseconds := __ptw32_relmillisecs (abstime);
  end;
  __ptw32_mcs_lock_acquire(@__ptw32_thread_reuse_lock, @node);
  if (nil = tp) or  (thread.x <> tp.ptHandle.x) then
  begin
      result := ESRCH;
  end
  else
  if (Int(PTHREAD_CREATE_DETACHED) = tp.detachState) then
  begin
    result := EINVAL;
  end
  else
  begin
    result := 0;
  end;
  __ptw32_mcs_lock_release(@node);
  if result = 0 then
  begin

      self := pthread_self();
      if nil = self.p then
      begin
          result := ENOENT;
      end
      else
      if (pthread_equal (self, thread)) then
      begin
        result := EDEADLK;
      end
      else
      begin

        result := pthreadCancelableTimedWait (tp.threadH, milliseconds);
        if 0 = result then
        begin
            if value_ptr <> nil then
              begin
                value_ptr^ := tp.exitStatus;
              end;

            result := pthread_detach (thread);
        end
        else
        if (ETIMEDOUT <> result) then
        begin
          result := ESRCH;
        end;
      end;
  end;
  Exit((result));
end;

function pthread_timechange_handler_np( arg : Pointer):Pointer;
var
  result1: Integer;
  cv : pthread_cond_t;
  node : __ptw32_mcs_local_node_t;
begin
  result1 := 0;
  __ptw32_mcs_lock_acquire(@__ptw32_cond_list_lock, @node);
  cv := __ptw32_cond_list_head;
  while (cv <> nil)  and  (0 = result1) do
    begin
      result1 := pthread_cond_broadcast (@cv);
      cv := cv.next;
    end;
  __ptw32_mcs_lock_release(@node);
  if result1 <> 0  then
     Result1 := EAGAIN
  else
     Result1 := 0;
  Result := Pointer(size_t (Result1));
end;

function __ptw32_cond_check_need_init( cond : Ppthread_cond_t):integer;
var

  node : __ptw32_mcs_local_node_t;
begin
  result := 0;
  
  __ptw32_mcs_lock_acquire(@__ptw32_cond_test_init_lock, @node);
  
  if cond^ = PTHREAD_COND_INITIALIZER then begin 
      result := pthread_cond_init (cond, nil);
    end 
  else 
  if ( cond^ = nil) then
  begin 
    
    result := EINVAL;
  end; 
  __ptw32_mcs_lock_release(@node);

end;


procedure __ptw32_threadStart( vthreadParms : Pointer);
var
  threadParms : PThreadParms;
  self        : pthread_t;
  sp          : __Pptw32_thread_t;
  arg         : Pointer;
  {$IF defined(__PTW32_CLEANUP_C)}

  setjmp_rc   : integer;
  {$IFEND}
  stateLock   : __ptw32_mcs_local_node_t;
  status      : Pointer;
  start       : Pstart_func;
begin
  threadParms := PThreadParms ( vthreadParms);
 
{$IF defined(__PTW32_CLEANUP_SEH)}
  DWORD
  ei[] := begin  0, 0, 0 end; 
;
{$IFEND}

  status := Pointer( 0);
  self := threadParms.tid;
  sp := __Pptw32_thread_t( self.p);
  start := threadParms.start;
  arg := threadParms.arg;
  free (threadParms);
{$IF not  defined (__MINGW32__)  or  defined (__MSVCRT__)  or  defined (__DMC__)}
{$ELSE }
  sp.thread := GetCurrentThreadId ();
{$IFEND}
  pthread_setspecific (__ptw32_selfThreadKey, sp);
  
  __ptw32_mcs_lock_acquire (@sp.stateLock, @stateLock);
  sp.state := PThreadStateRunning;
  __ptw32_mcs_lock_release (@stateLock);
{$IF defined(__PTW32_CLEANUP_SEH)}
  __try
  begin 
    
    status := sp.exitStatus = ( *start) (arg);
    sp.state := PThreadStateExiting;
{$IF defined(_UWIN)}
    if PreDec(pthread_count then <= 0)
      exit (0);
{$IFEND}
  end; 
  __except (ExceptionFilter (GetExceptionInformation (), ei))
  begin 
    case ei[0] of
        __PTW32_EPS_CANCEL: 
          status := sp.exitStatus = PTHREAD_CANCELED;
{$IF defined(_UWIN)}
          if PreDec(pthread_count then <= 0)
          exit (0);
{$IFEND}
          break;
        __PTW32_EPS_EXIT: 
          status := sp.exitStatus;
          break;
        else
          status := sp.exitStatus = PTHREAD_CANCELED;
          break;
      end; 
  end; 
{$ELSE }
{$IF defined(__PTW32_CLEANUP_C)}
  setjmp_rc := setjmp (sp.start_mark);
  if 0 = setjmp_rc then begin 
      
      status := sp.exitStatus = ( *start) (arg);
      sp.state := PThreadStateExiting;
    end; 
  else
    begin 
      case setjmp_rc of
          __PTW32_EPS_CANCEL: 
          status := sp.exitStatus = PTHREAD_CANCELED;
          break;
          __PTW32_EPS_EXIT: 
          status := sp.exitStatus;
          break;
          else
          status := sp.exitStatus = PTHREAD_CANCELED;
          break;
        end; 
    end; 
{$ELSE }

{$IFEND}
{$IFEND}
{$IF defined (__PTW32_STATIC_LIB)}
  (void) pthread_win32_thread_detach_np ();
{$IFEND}
{$IF  defined (__MSVCRT__)  and not  defined (FPC)}
  {$if CompilerVersion <= 23}
   endthread (uint32(size_t(status)));
  {$else}
  _endthreadex (uint32(size_t(status)));
  {$ifend}
{$ELSE} 
  endthread ();
{$IFEND}
  
{$IF defined (__MSVCRT__)  and not  defined (FPC)}

  {$if CompilerVersion <= 23}
   endthread (uint32(size_t(status)));
  {$else}
  _endthreadex (uint32(size_t(status)));
  {$ifend}
{$IFEND}
end;

{$if defined(__PTW32_USES_SEPARATE_CRT) and (defined(__PTW32_CLEANUP_CXX) or defined(__PTW32_CLEANUP_SEH))}
function pthread_win32_set_terminate_np( termFunction : __ptw32_terminate_handler):__ptw32_terminate_handler;
begin
  Result := set_terminate(termFunction);
end;
{$IFEND}

procedure __ptw32_timespec_to_filetime(const ts : Ptimespec; ft : PFILETIME);
begin
   Puint64_t(ft)^ := ts.tv_sec * 10000000
    + (ts.tv_nsec + 50) div 100 +  __PTW32_TIMESPEC_TO_FILETIME_OFFSET;
end;


procedure __ptw32_filetime_to_timespec(const ft : PFILETIME; ts : Ptimespec);
begin
  ts.tv_sec := int (( Puint64_t(ft)^  -  __PTW32_TIMESPEC_TO_FILETIME_OFFSET) div 10000000);
  ts.tv_nsec := int (( Puint64_t(ft)^  -  __PTW32_TIMESPEC_TO_FILETIME_OFFSET -
                       uint64_t( ts.tv_sec) * uint64_t( 10000000) * 100));
end;

function sched_get_priority_max( policy : integer):integer;
begin
  if (policy < Int(SCHED_MIN))  or  (policy > Int(SCHED_MAX)) then begin 
       __PTW32_SET_ERRNO(EINVAL);
      Exit(-1);
    end; 
{$IF (THREAD_PRIORITY_LOWEST > THREAD_PRIORITY_NORMAL)}
 
  Exit(__PTW32_MAX (THREAD_PRIORITY_IDLE, THREAD_PRIORITY_TIME_CRITICAL));
{$ELSE /}
  Exit(__PTW32_MAX (THREAD_PRIORITY_IDLE, THREAD_PRIORITY_TIME_CRITICAL));
{$IFEND}
end;

function sched_getscheduler( pid : pid_t):integer;
var
  selfPid : integer;
  h : THANDLE;
begin
  
  if 0 <> pid then begin 
      selfPid := int( GetCurrentProcessId);
      if pid <> selfPid then 
      begin 
         h := OpenProcess (PROCESS_QUERY_INFORMATION,  LongBool(__PTW32_FALSE), DWORD( pid));
          if Null = ( h) then
          begin 
            if ($FF and ERROR_ACCESS_DENIED) = GetLastError() then
              __PTW32_SET_ERRNO(EPERM)
            else
              __PTW32_SET_ERRNO(ESRCH);   
            Exit(-1);
          end 
          else
            CloseHandle(h);
      end; 
  end; 
  Result := Int(SCHED_OTHER);
end;

function sched_setaffinity( pid : pid_t; cpusetsize : NativeUInt; &set : Pcpu_set_t):integer;
var
  vProcessMask, 
  vSystemMask  : DWORD_PTR;
  h            : THANDLE;
  targetPid, 
 
  newMask      : DWORD_PTR;
begin
{$IF not  defined(NEED_PROCESS_AFFINITY_MASK)}
  targetPid := int(size_t( pid));
  result := 0;
  if nil = &set then begin 
    result := EFAULT;
  end 
  else
  begin 
    if 0 = targetPid then begin 
      targetPid := int( GetCurrentProcessId);
    end; 
    h := OpenProcess (PROCESS_QUERY_INFORMATION or PROCESS_SET_INFORMATION,  LongBool(__PTW32_FALSE), DWORD( targetPid));
    if Null = ( h) then
    begin 
      if ($FF and ERROR_ACCESS_DENIED) = GetLastError then
         result := EPERM 
      else
         Result := ESRCH;
    end 
    else
    begin 
      if GetProcessAffinityMask (h, &vProcessMask, &vSystemMask ) then 
      begin 
        
        newMask := vSystemMask and (_Psched_cpu_set_vector_(&set))._cpuset;
        if newMask>0 then 
        begin 
          if SetProcessAffinityMask(h, newMask) = LongBool(0) then 
          begin 
            case (GetLastError()) of
              
                ($FF and ERROR_ACCESS_DENIED): 
                  result := EPERM;
                 
                ($FF and ERROR_INVALID_PARAMETER): 
                  result := EINVAL;
               
                else
                  result := EAGAIN;
                
               
            end; 
          end 
          else
          begin 
            result := EINVAL;
          end; 
        end 
        else
        begin 
          result := EAGAIN;
        end; 
    end; 
    CloseHandle(h);
  end; 
  if result <> 0 then begin 
     __PTW32_SET_ERRNO(result);
    Exit(-1);
    end
  else
      Exit(0);
  
{$ELSE __PTW32_SET_ERRNO(ENOSYS);}
  Exit(-1);
{$IFEND}
  end;
end;

function _sched_affinitycpucount(const &set : Pcpu_set_t):integer;
var
  tset : size_t;
  count : integer;
begin
  count := 0;
  tset := _Psched_cpu_set_vector_(&set)._cpuset;
  while ( tset>0 ) do
  begin 
    if (tset and (size_t(1)))>0  then
       Inc(count);
  
    tset := tset shr  1;
  end; 
    
  Result := count;
end;


procedure _sched_affinitycpuzero( pset : Pcpu_set_t);
begin
  _Psched_cpu_set_vector_(pset)._cpuset := size_t(0);
end;


procedure _sched_affinitycpuset( cpu : integer; pset : Pcpu_set_t);
begin
  _Psched_cpu_set_vector_(pset)._cpuset  := _Psched_cpu_set_vector_(pset)._cpuset  or (size_t(1)  shl  cpu);
end;


procedure _sched_affinitycpuclr( cpu : integer; pset : Pcpu_set_t);
begin
  _Psched_cpu_set_vector_(pset)._cpuset := _Psched_cpu_set_vector_(pset)._cpuset and
                                        not (size_t(1)  shl  cpu);
end;


function _sched_affinitycpuisset(cpu : integer;const pset : Pcpu_set_t):Boolean;
begin
  Result := (_Psched_cpu_set_vector_(pset)._cpuset and
      (size_t(1)  shl  cpu)) <> size_t(0);
end;


procedure _sched_affinitycpuand(pdestset : Pcpu_set_t;const psrcset1 : Pcpu_set_t;const psrcset2 : Pcpu_set_t);
begin
  _Psched_cpu_set_vector_(pdestset)._cpuset :=
      (_Psched_cpu_set_vector_(psrcset1)._cpuset and 
          _Psched_cpu_set_vector_(psrcset2)._cpuset);
end;


procedure _sched_affinitycpuor(pdestset : Pcpu_set_t;const psrcset1 : Pcpu_set_t; const psrcset2 : Pcpu_set_t);
begin
  _Psched_cpu_set_vector_(pdestset)._cpuset :=
      (_Psched_cpu_set_vector_(psrcset1)._cpuset or 
          _Psched_cpu_set_vector_(psrcset2)._cpuset);
end;


procedure _sched_affinitycpuxor(pdestset : Pcpu_set_t;const psrcset1 : Pcpu_set_t;const psrcset2 : Pcpu_set_t);
begin
  _Psched_cpu_set_vector_(pdestset)._cpuset :=
      (_Psched_cpu_set_vector_(psrcset1)._cpuset  xor 
          _Psched_cpu_set_vector_(psrcset2)._cpuset);
end;


function _sched_affinitycpuequal(const pset1, pset2 : Pcpu_set_t):Boolean;
begin
  Result := _Psched_cpu_set_vector_(pset1)._cpuset =
      _Psched_cpu_set_vector_(pset2)._cpuset;
end;

function sched_get_priority_min( policy : integer):integer;
begin
  if (policy < Int(SCHED_MIN))  or  (policy > Int(SCHED_MAX)) then begin 
       __PTW32_SET_ERRNO(EINVAL);
      Exit(-1);
    end; 
{$IF (THREAD_PRIORITY_LOWEST > THREAD_PRIORITY_NORMAL)}
  
  Exit(__PTW32_MIN (THREAD_PRIORITY_IDLE, THREAD_PRIORITY_TIME_CRITICAL));
{$ELSE }
  Exit(__PTW32_MIN (THREAD_PRIORITY_IDLE, THREAD_PRIORITY_TIME_CRITICAL));
{$IFEND}
end;

function sched_setscheduler( pid : pid_t; policy : integer):integer;
var
  selfPid : integer;
  h : THANDLE;
begin
  
  if 0 <> pid then 
  begin 
      selfPid := int( GetCurrentProcessId );
      if pid <> selfPid then 
      begin 
        h := OpenProcess (PROCESS_SET_INFORMATION,  LongBool(__PTW32_FALSE), DWORD(pid));
        if Null = ( h) then
        begin 
           if (GetLastError = ($FF and ERROR_ACCESS_DENIED)) then
              __PTW32_SET_ERRNO(EPERM)
           else
              __PTW32_SET_ERRNO(ESRCH);
           Exit(-1);
        end 
        else
      CloseHandle(h);
      end; 
  end; 
  if Int(SCHED_OTHER) <> policy then 
  begin
       __PTW32_SET_ERRNO(ENOSYS);
      Exit(-1);
  end; 
  
  Result := Int(SCHED_OTHER);
end;



function sem_close(sem: Psem_t): Integer;
begin
   __PTW32_SET_ERRNO(ENOSYS);
  Result := -1;
end;

function sem_destroy( sem : Psem_t):integer;
var

  s : sem_t;
  node : __ptw32_mcs_local_node_t;
begin
  result := 0;
  s := nil;
  if (sem = nil)  or  (sem^ = nil) then begin 
      result := EINVAL;
    end 
  else
  begin 
    s := sem^;
    result := __ptw32_mcs_lock_try_acquire(@s.lock, @node);
    if result =  0 then 
    begin 
        if s.value < 0 then 
        begin 
          result := EBUSY;
        end 
        else
        begin 
            
          if  not CloseHandle (s.sem ) then
            begin 
              result := EINVAL;
            end; 
        end; 
        __ptw32_mcs_lock_release(@node);
      end; 
  end; 
  if result <> 0 then begin 
       __PTW32_SET_ERRNO(result);
      Exit(-1);
    end; 
  free (s);
  Exit(0);
end;

function sem_getvalue( sem : Psem_t; sval : Pinteger):integer;
var
  s: sem_t;
  node : __ptw32_mcs_local_node_t;
begin
  result := 0;
  s := sem^;
  __ptw32_mcs_lock_acquire(@s.lock, @node);
  sval^ := s.value;
  __ptw32_mcs_lock_release(@node);
  if result <> 0 then 
  begin 
       __PTW32_SET_ERRNO(result);
      Exit(-1);
  end; 
  Result := 0;
end;

function sem_init( sem : Psem_t; pshared : integer; value : uint32):integer;
var

  s : sem_t;
begin
  result := 0;
  s := nil;
  if pshared <> 0 then begin 
      
      result := EPERM;
  end 
  else 
  if value > UInt32(SEM_VALUE_MAX) then
  begin 
    result := EINVAL;
  end 
  else
    begin 
      s := sem_t( calloc (1, sizeof ( s^)));
      if nil = s then begin 
          result := ENOMEM;
        end 
      else
      begin 
        s.value := value;
        s.lock := nil;
{$IF defined(NEED_SEM)}
        s.sem := CreateEvent (nil,
             __PTW32_FALSE,  /
             __PTW32_FALSE,  /
            nil);
        if 0 = s.sem then 
        begin 
            result := ENOSPC;
        end 
        else
        begin 
          s.leftToUnblock := 0;
        end; 
{$ELSE }
        s.sem := CreateSemaphore (nil,  
                                  long (0),  
                                  long( SEM_VALUE_MAX),  
                                  nil);
        if (s.sem = 0) then  
          begin 
            result := ENOSPC;
          end; 
{$IFEND}
        if result <> 0 then begin 
            free(s);
          end; 
      end; 
    end; 
  if result <> 0 then begin 
       __PTW32_SET_ERRNO(result);
      Exit(-1);
    end; 
  sem^ := s;
  Exit(0);
end;

function sem_open(const name : Pchar; oflag : integer):Psem_t; //cdecl;varargs;  
begin
  
   __PTW32_SET_ERRNO(ENOSYS);
  Result := SEM_FAILED;
end;

function sem_post( sem : Psem_t):integer;
var
 
  node : __ptw32_mcs_local_node_t;
  s : sem_t;
begin
  result := 0;
  s := sem^;
  __ptw32_mcs_lock_acquire(@s.lock, @node);
  if s.value < SEM_VALUE_MAX then 
  begin 
{$IF defined(NEED_SEM)}
      if PreInc(s then .value <= 0
           and   not SetEvent(s.sem))
        begin 
          s.PostDec(value);
          result := EINVAL;
        end; 
{$ELSE} 
       Inc(s .value);
       if (s.value <= 0)  
           and   (not ReleaseSemaphore (s.sem, 1, nil)) then 
        begin 
          Dec(s.value);
          result := EINVAL;
        end; 
{$IFEND}
  end 
  else
  begin 
    result := ERANGE;
  end; 
  __ptw32_mcs_lock_release(@node);
  if result <> 0 then 
  begin 
       __PTW32_SET_ERRNO(result);
      Exit(-1);
  end; 
  Result := 0;
end;

function sem_post_multiple( sem : Psem_t; count : integer):integer;
var
  node : __ptw32_mcs_local_node_t;
  n: Integer;
  waiters : long;
  s : sem_t;
begin
  result := 0;
  s := sem^;
  __ptw32_mcs_lock_acquire(@s.lock, @node);
  if s.value <= (SEM_VALUE_MAX - count ) then 
  begin 
      waiters := -s.value;
      s.value  := s.value + count;
      if waiters > 0 then 
      begin 
{$IF defined(NEED_SEM)}
          if SetEvent(s.sem) then 
            begin 
              PostDec(waiters);
              s.leftToUnblock  := s.leftToUnblock + (count - 1);
              if s.leftToUnblock > waiters then begin 
                  s.leftToUnblock := waiters;
                end; 
            end; 
{$ELSE} 
          if waiters<=count then 
             n := waiters
          else
             n := count ;
    
          if ReleaseSemaphore (s.sem,  n, nil) then
          begin 
      
          end 
{$IFEND}
          else
          begin 
            s.value  := s.value - count;
            result := EINVAL;
          end; 
      end; 
  end 
  else
  begin 
    result := ERANGE;
  end; 
  __ptw32_mcs_lock_release(@node);
  if result <> 0 then 
  begin 
       __PTW32_SET_ERRNO(result);
      Exit(-1);
  end; 
  Result := 0;
end;

procedure __ptw32_sem_timedwait_cleanup( args : Pointer);
var
  node : __ptw32_mcs_local_node_t;
  a : Psem_timedwait_cleanup_args_t;
  s : sem_t;
begin
  a := Psem_timedwait_cleanup_args_t(args);
  s := a.sem;
  __ptw32_mcs_lock_acquire(@s.lock, @node);
  
  if WaitForSingleObject(s.sem, 0 ) = WAIT_OBJECT_0 then
  begin 
    
    a.resultPtr^ := 0;
  end 
  else
    begin 
    
      Inc(s.value);
{$IF defined(NEED_SEM)}
      if s.value > 0 then begin 
          s.leftToUnblock := 0;
        end; 
{$ELSE }
{$IFEND}
    end; 
  __ptw32_mcs_lock_release(@node);
end;

function sem_timedwait(sem : Psem_t;const abstime : Ptimespec):integer;
var
  node         : __ptw32_mcs_local_node_t;
  milliseconds : DWORD;
  v            : int;
 
  s            : sem_t;
  timedout     : integer;
  cleanup_args : sem_timedwait_cleanup_args_t;
  {$IF defined(NEED_SEM)}
      timedout : Int; 
  {$IFEND}
begin
  result := 0;
  s := sem^;
  pthread_testcancel();
  if abstime = nil then begin 
      milliseconds := INFINITE;
    end
  else
  begin 
   
    milliseconds := __ptw32_relmillisecs (abstime);
  end; 
  __ptw32_mcs_lock_acquire(@s.lock, @node);
  Dec(s.value);
  v := s.value;
  __ptw32_mcs_lock_release(@node);
  if v < 0 then 
  begin 
{$IF defined(NEED_SEM)}
{$IFEND}
      cleanup_args.sem := s;
      cleanup_args.resultPtr := @result;

      pthread_cleanup_push(@__ptw32_sem_timedwait_cleanup, Pointer(@cleanup_args));

          result := pthreadCancelableTimedWait (s.sem, milliseconds);
      pthread_cleanup_pop(result);

{$IF defined(NEED_SEM)}
      if  not timedout then 
      begin 
          __ptw32_mcs_lock_acquire(&s.lock, &node);
          if s.leftToUnblock > 0 then 
          begin 
              PreDec(s).leftToUnblock;
              SetEvent(s.sem);
            end; 
          __ptw32_mcs_lock_release(&node);
      end; 
{$IFEND}
end; 
  if result <> 0 then begin 
       __PTW32_SET_ERRNO(result);
      Exit(-1);
    end; 
  Exit(0);
end;

function sem_trywait( sem : Psem_t):integer;
var

  s : sem_t;
  node : __ptw32_mcs_local_node_t;
begin
  result := 0;
  s := sem^;
  __ptw32_mcs_lock_acquire(@s.lock, @node);
  if s.value > 0 then begin 
      Dec(s.value);
  end 
  else
  begin 
    result := EAGAIN;
  end; 
  __ptw32_mcs_lock_release(@node);
  if result <> 0 then 
  begin 
       __PTW32_SET_ERRNO(result);
      Exit(-1);
  end; 
  Exit(0);
end;

function sem_unlink(const name : Pchar):integer;
begin
   __PTW32_SET_ERRNO(ENOSYS);
  Result := -1;
end;

procedure __ptw32_sem_wait_cleanup( sem : Pointer);
var
  s : sem_t;
  node : __ptw32_mcs_local_node_t;
begin
  s := sem_t( sem);
  __ptw32_mcs_lock_acquire(@s.lock, @node);
  
  if (Psem_t(sem)^ <> nil ) and   
     (WaitForSingleObject(s.sem, 0) <> WAIT_OBJECT_0) then
    begin 
      Inc(s.value);
{$IF defined(NEED_SEM)}
      if s.value > 0 then begin 
          s.leftToUnblock := 0;
        end; 
{$ELSE }
{$ifEND }
    end; 
  __ptw32_mcs_lock_release(@node);
end;


function sem_wait( sem : Psem_t):integer;
var
  node : __ptw32_mcs_local_node_t;
  v : integer;
  s : sem_t;
begin
  result := 0;
  s := sem^;
  pthread_testcancel();
  __ptw32_mcs_lock_acquire(@s.lock, @node);
  Dec(s.value);
  v := s.value;
  __ptw32_mcs_lock_release(@node);
  if v < 0 then 
  begin 

      pthread_cleanup_push(@__ptw32_sem_wait_cleanup, Pointer(s));
      result := pthreadCancelableWait (s.sem);

      pthread_cleanup_pop(result);

  end;
{$IF defined(NEED_SEM)}
  if  0>= result then
  begin
      __ptw32_mcs_lock_acquire(&s.lock, &node);
      if s.leftToUnblock > 0 then begin 
          PreDec(s).leftToUnblock;
          SetEvent(s.sem);
        end; 
      __ptw32_mcs_lock_release(&node);
    end; 
{$IFEND}
  if result <> 0 then begin 
       __PTW32_SET_ERRNO(result);
      Exit(-1);
    end; 
  Exit(0);
end;

function pthread_mutex_init(mutex : Ppthread_mutex_t;const attr : Ppthread_mutexattr_t):integer;
var

  mx : pthread_mutex_t;
begin
  result := 0;
  if mutex = nil then
      Exit(EINVAL);

  if (attr <> nil)  and  (attr^ <> nil) then
  begin
      if attr^.pshared = Int(PTHREAD_PROCESS_SHARED) then
        begin
{$IF _POSIX_THREAD_PROCESS_SHARED >= 0}
          raise Exception.Create(' Process shared mutexes are not supported yet.');
{$ELSE}
          Exit(ENOSYS);
{$IFEND}
        end;
  end;
  mx := pthread_mutex_t( calloc (1, sizeof ( mx^)));
  if mx = nil then
      result := ENOMEM

  else
  begin
      mx.lock_idx := 0;
      mx.recursive_count := 0;
      mx.robustNode := nil;
      if (attr = nil)  or  (attr^ = nil) then
          mx.kind := Int(PTHREAD_MUTEX_DEFAULT)

      else
      begin
          mx.kind := attr^.kind;
          if attr^.robustness = Int(PTHREAD_MUTEX_ROBUST) then
          begin
            mx.kind := -mx.kind - 1;
            mx.robustNode := __Pptw32_robust_node_t( malloc(sizeof(__ptw32_robust_node_t)));
            if nil = mx.robustNode then
               result := ENOMEM

            else
            begin
              mx.robustNode.stateInconsistent := __PTW32_ROBUST_CONSISTENT;
              mx.robustNode.mx := mx;
              mx.robustNode.next := nil;
              mx.robustNode.prev := nil;
            end;
          end;
      end;
      if 0 = result then
      begin
          mx.ownerThread.p := nil;
          mx.event := CreateEvent (nil,  __PTW32_FALSE, __PTW32_FALSE, nil);
          if 0 = mx.event then
             result := ENOSPC
          else
             SetEvent(mx.event);
      end;
  end;

  if 0 <> result then
  begin
      if nil <> mx.robustNode then
         free (mx.robustNode);

      free (mx);
      mx := nil;
  end;
  mutex^ := mx;

end;

function pthread_mutex_destroy( mutex : Ppthread_mutex_t):integer;
var
  mx   : pthread_mutex_t;
  node : __ptw32_mcs_local_node_t;
begin

  result := 0;

  if mutex^ < (PTHREAD_ERRORCHECK_MUTEX_INITIALIZER) then
  begin
      mx := mutex^;
      result := pthread_mutex_trylock (@mx);

      if (0 = result)  or  (ENOTRECOVERABLE = result) then
      begin
          if (mx.kind <> Int(PTHREAD_MUTEX_RECURSIVE) )  or  (1 = mx.recursive_count) then
          begin

            mutex^ := nil;
            if (0 = result) then
               result := pthread_mutex_unlock(@mx)
            else
               result := 0;
            if 0 = result then
            begin
              if mx.robustNode <> nil then
                 free(mx.robustNode);

              if  not CloseHandle (mx.event ) then
                begin
                  mutex^ := mx;
                  result := EINVAL;
                end
                else
                  free (mx);

            end
            else
              mutex^ := mx;

          end
          else
          begin

            Dec(mx.recursive_count);
            result := EBUSY;
          end;
      end;
  end
  else
  begin

    __ptw32_mcs_lock_acquire(@__ptw32_mutex_test_init_lock, @node);

    if mutex^ >= PTHREAD_ERRORCHECK_MUTEX_INITIALIZER then
       mutex^ := nil
    else
       result := EBUSY;

    __ptw32_mcs_lock_release(@node);
  end;

end;

function pthread_rwlock_tryrdlock( rwlock : Ppthread_rwlock_t):integer;
var

  rwl : pthread_rwlock_t;
begin
  if (rwlock = nil)  or  (rwlock^ = nil) then begin
      Exit(EINVAL);
    end;
  if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
  begin
      result := __ptw32_rwlock_check_need_init (rwlock);
      if (result <> 0)  and  (result <> EBUSY) then begin
        Exit(result);
      end;
  end;
  rwl := rwlock^;
  if rwl.nMagic <>  __PTW32_RWLOCK_MAGIC then begin
      Exit(EINVAL);
    end;
  result := pthread_mutex_trylock (@rwl.mtxExclusiveAccess );
  if Result <> 0 then
    begin
      Exit(result);
    end;
  Inc(rwl.nSharedAccessCount);
  if (rwl.nSharedAccessCount = INT_MAX) then
  begin
    result := pthread_mutex_lock (@rwl.mtxSharedAccessCompleted);
    if (Result <> 0) then
    begin
      pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
      Exit(result);
    end;
    rwl.nSharedAccessCount  := rwl.nSharedAccessCount - rwl.nCompletedSharedAccessCount;
    rwl.nCompletedSharedAccessCount := 0;
    result := pthread_mutex_unlock (@rwl.mtxSharedAccessCompleted);
    if (Result <> 0) then
    begin
      pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
      Exit(result);
    end;
  end;
  Result := (pthread_mutex_unlock (@rwl.mtxExclusiveAccess));
end;

procedure __ptw32_rwlock_cancelwrwait( arg : Pointer);
var
  rwl : pthread_rwlock_t;
begin
  rwl := pthread_rwlock_t( arg);
  rwl.nSharedAccessCount := -rwl.nCompletedSharedAccessCount;
  rwl.nCompletedSharedAccessCount := 0;
  pthread_mutex_unlock (@(rwl.mtxSharedAccessCompleted));
  pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
end;


function pthread_rwlock_timedwrlock(rwlock : Ppthread_rwlock_t;const abstime : Ptimespec):integer;
var
  rwl : pthread_rwlock_t;
begin
  if (rwlock = nil)  or  (rwlock^ = nil) then
      Exit(EINVAL);

  if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
  begin
      result := __ptw32_rwlock_check_need_init (rwlock);
      if (result <> 0)  and  (result <> EBUSY) then
        Exit(result);

  end;
  rwl := rwlock^;
  if rwl.nMagic <>  __PTW32_RWLOCK_MAGIC then
      Exit(EINVAL);

  result := pthread_mutex_timedlock (@rwl.mtxExclusiveAccess, abstime);
  if (result <> 0)  then
  begin
    Exit(result);
  end;

  result := pthread_mutex_timedlock (@rwl.mtxSharedAccessCompleted  , abstime);
  if (result <> 0)  then
  begin
    pthread_mutex_unlock (@rwl.mtxExclusiveAccess);
    Exit(result);
  end;
  if rwl.nExclusiveAccessCount = 0 then
  begin
      if rwl.nCompletedSharedAccessCount > 0 then
      begin
        rwl.nSharedAccessCount  := rwl.nSharedAccessCount - rwl.nCompletedSharedAccessCount;
        rwl.nCompletedSharedAccessCount := 0;
      end;
      if rwl.nSharedAccessCount > 0 then
      begin
         rwl.nCompletedSharedAccessCount := -rwl.nSharedAccessCount;

        pthread_cleanup_push (Addr(__ptw32_rwlock_cancelwrwait), Pointer( rwl));

        repeat
          result := pthread_cond_timedwait (@rwl.cndSharedAccessCompleted,
                                            @rwl.mtxSharedAccessCompleted,
                                            abstime);
        until (result <> 0)  and  (rwl.nCompletedSharedAccessCount >= 0);

        if (result <> 0) then
           pthread_cleanup_pop (1)
        else
           pthread_cleanup_pop (0);

        if result = 0 then
            rwl.nSharedAccessCount := 0;

      end;
  end;
  if result = 0 then
     Inc( rwl.nExclusiveAccessCount);


end;

function __ptw32_rwlock_check_need_init( rwlock : Ppthread_rwlock_t):integer;
var

  node : __ptw32_mcs_local_node_t;
begin
  result := 0;
  __ptw32_mcs_lock_acquire(@__ptw32_rwlock_test_init_lock, @node);
  if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
  begin
      result := pthread_rwlock_init (rwlock, nil);
  end
  else
  if ( rwlock^ = nil) then
  begin
    result := EINVAL;
  end;
  __ptw32_mcs_lock_release(@node);
  Result := result;
end;

function pthread_rwlock_timedrdlock(rwlock : Ppthread_rwlock_t;const abstime : Ptimespec):integer;
var

  rwl : pthread_rwlock_t;
begin
  if (rwlock = nil)  or  (rwlock^ = nil) then
  begin
      Exit(EINVAL);
  end;
  if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
  begin
      result := __ptw32_rwlock_check_need_init (rwlock);
      if (result <> 0)  and  (result <> EBUSY) then
        Exit(result);

  end;
  rwl := rwlock^;
  if rwl.nMagic <>  __PTW32_RWLOCK_MAGIC then
      Exit(EINVAL);
  result := pthread_mutex_timedlock (@rwl.mtxExclusiveAccess , abstime);
  if (Result <> 0)  then
    begin
      Exit(result);
    end;
  Inc(rwl.nSharedAccessCount);
  if (rwl.nSharedAccessCount = INT_MAX) then
  begin
    result := pthread_mutex_timedlock (@rwl.mtxSharedAccessCompleted,  abstime);
    if (Result <> 0) then
    begin
      if result = ETIMEDOUT then
        begin
          Inc(rwl.nCompletedSharedAccessCount);
        end;
      pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
      Exit(result);
    end;
    rwl.nSharedAccessCount  := rwl.nSharedAccessCount - rwl.nCompletedSharedAccessCount;
    rwl.nCompletedSharedAccessCount := 0;
    result := pthread_mutex_unlock (@rwl.mtxSharedAccessCompleted);
    if ( Result <> 0) then
    begin
      pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
      Exit(result);
    end;
  end;
  Result := pthread_mutex_unlock (@rwl.mtxExclusiveAccess);
end;

function pthread_rwlock_rdlock( rwlock : Ppthread_rwlock_t):integer;
var

  rwl : pthread_rwlock_t;
begin
  if (rwlock = nil)  or  (rwlock^ = nil) then begin
      Exit(EINVAL);
    end;
  if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
  begin
      result := __ptw32_rwlock_check_need_init (rwlock);
      if (result <> 0 ) and  (result <> EBUSY) then
      begin
        Exit(result);
      end;
    end;
  rwl := rwlock^;
  if rwl.nMagic <>  __PTW32_RWLOCK_MAGIC then begin
      Exit(EINVAL);
    end;
  result := pthread_mutex_lock (@rwl.mtxExclusiveAccess );
  if Result <> 0 then
    begin
      Exit(result);
    end;
  Inc(rwl.nSharedAccessCount);
  if rwl.nSharedAccessCount = INT_MAX then
    begin
      result := pthread_mutex_lock (@rwl.mtxSharedAccessCompleted);
      if (Result <> 0) then
      begin
        pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
        Exit(result);
      end;
      rwl.nSharedAccessCount  := rwl.nSharedAccessCount - rwl.nCompletedSharedAccessCount;
      rwl.nCompletedSharedAccessCount := 0;
      result := pthread_mutex_unlock (@rwl.mtxSharedAccessCompleted );
      if ( Result <> 0)   then
      begin
        pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
        Exit(result);
      end;
    end;
  Result := pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
end;

function pthread_rwlock_init(rwlock : Ppthread_rwlock_t;const attr : Ppthread_rwlockattr_t):integer;
var

  rwl : pthread_rwlock_t;
  label FAIL0, FAIL1, FAIL2, DONE ;
begin
  rwl := nil;
  if rwlock = nil then begin
      Exit(EINVAL);
    end;
  if (attr <> nil)  and  (attr^ <> nil) then begin
      result := EINVAL;
    end;
  rwl := pthread_rwlock_t( calloc (1, sizeof ( rwl^)));
  if rwl = nil then begin
      result := ENOMEM;
    end;
  rwl.nSharedAccessCount := 0;
  rwl.nExclusiveAccessCount := 0;
  rwl.nCompletedSharedAccessCount := 0;
  result := pthread_mutex_init (@rwl.mtxExclusiveAccess, nil);
  if result <> 0 then begin
    end;
  result := pthread_mutex_init (@rwl.mtxSharedAccessCompleted, nil);
  if result <> 0 then begin
    end;
  result := pthread_cond_init (@rwl.cndSharedAccessCompleted, nil);
  if result <> 0 then begin
    end;
  rwl.nMagic := __PTW32_RWLOCK_MAGIC;
  result := 0;
FAIL2:
  pthread_mutex_destroy (@(rwl.mtxSharedAccessCompleted));
FAIL1:
  pthread_mutex_destroy (@(rwl.mtxExclusiveAccess));
FAIL0:
  free (rwl);
  rwl := nil;
DONE:
  rwlock^ := rwl;
  Result := result;
end;




function pthread_rwlock_destroy( rwlock : Ppthread_rwlock_t):integer;
var
  rwl : pthread_rwlock_t;
  result0, result1, result2 : integer;
  node : __ptw32_mcs_local_node_t;
begin
  result0 := 0; result1 := 0; result2 := 0;
  if (rwlock = nil)  or  (rwlock^ = nil) then begin
      Exit(EINVAL);
    end;
  if rwlock^ <> PTHREAD_RWLOCK_INITIALIZER then
  begin
      rwl := rwlock^;
      if rwl.nMagic <>  __PTW32_RWLOCK_MAGIC then
         Exit(EINVAL);
      result0 := pthread_mutex_lock (@rwl.mtxExclusiveAccess);
      if result0 <> 0 then
      begin
        Exit(result0);
      end;
      result0 := pthread_mutex_lock (@rwl.mtxSharedAccessCompleted);
      if ( result0 <> 0)  then
      begin
        pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
        Exit(result0);
      end;

      if (rwl.nExclusiveAccessCount > 0) or
         (rwl.nSharedAccessCount > rwl.nCompletedSharedAccessCount) then
      begin
        result0 := pthread_mutex_unlock (@(rwl.mtxSharedAccessCompleted));
        result1 := pthread_mutex_unlock (@(rwl.mtxExclusiveAccess));
        result2 := EBUSY;
      end
      else
      begin
        rwl.nMagic := 0;
        result0 := pthread_mutex_unlock (@rwl.mtxSharedAccessCompleted);
        if ( result0 <> 0)  then
          begin
            pthread_mutex_unlock (@rwl.mtxExclusiveAccess);
            Exit(result0);
          end;
        result0 := pthread_mutex_unlock (@rwl.mtxExclusiveAccess );
        if (result0 <> 0) then
          begin
            Exit(result0);
          end;
        rwlock^ := nil;
        result := pthread_cond_destroy (@(rwl.cndSharedAccessCompleted));
        result1 := pthread_mutex_destroy (@(rwl.mtxSharedAccessCompleted));
        result2 := pthread_mutex_destroy (@(rwl.mtxExclusiveAccess));
        free (rwl);
      end;
  end
  else
  begin

    __ptw32_mcs_lock_acquire(@__ptw32_rwlock_test_init_lock, @node);

    if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
    begin

      rwlock^ := nil;
    end
    else
    begin

      result0 := EBUSY;
    end;
    __ptw32_mcs_lock_release(@node);
  end;
  //((result0 != 0) ? result0 : ((result1 != 0) ? result1 : result2));
  Result := get_result( result0 , get_result( result1 , result2));
end;


function pthread_once(once_control : Ppthread_once_t;init_routine : Ppthread_once_init_routine):integer;
var
  node : __ptw32_mcs_local_node_t;
begin
  if (once_control = nil)  or  (init_routine = nil) then begin
      Exit(EINVAL);
    end;
  if (__PTW32_INTERLOCKED_LONG ( __PTW32_FALSE) =
       __PTW32_INTERLOCKED_LONG(__PTW32_INTERLOCKED_EXCHANGE_ADD_LONG (__PTW32_INTERLOCKED_LONGPTR(@once_control.done)^,
                                                                   __PTW32_INTERLOCKED_LONG(0))) ) then
    begin
      __ptw32_mcs_lock_acquire(__Pptw32_mcs_lock_t (@once_control.lock), @node);
      if  0>= once_control.done then
      begin
      
          pthread_cleanup_push(@__ptw32_mcs_lock_release, @node);
          init_routine^();
          pthread_cleanup_pop(0);
     
          once_control.done := Int(__PTW32_TRUE);
      end;
      __ptw32_mcs_lock_release(@node);
    end;
  Exit(0);
end;

function __ptw32_getprocessors(count : Pinteger):integer;
var
  vProcessCPUs,
  vSystemCPUs  : DWORD_PTR;

  bit          : DWORD_PTR;
  CPUs         : integer;
begin
  result := 0;
{$IF defined(NEED_PROCESS_AFFINITY_MASK)}
  *count = 1;
{$ELSE}
  if GetProcessAffinityMask (GetCurrentProcess ,
            &vProcessCPUs, &vSystemCPUs) then
  begin
    CPUs := 0;
    bit := 1;
    while ( bit <> 0) do
    begin
      if (vProcessCPUs and bit)>0 then begin
          Inc(CPUs);
        end;
      bit := bit shl 1; //bit <<= 1
    end;
    count^ := CPUs;
  end
  else
    begin
      result := EAGAIN;
    end;
{$IFEND}

end;

function pthread_num_processors_np:integer;
var
  count : integer;
begin
  if __ptw32_getprocessors (@count) <> 0  then
    begin
      count := 1;
    end;
  Result := (count);
end;

function pthread_mutexattr_settype( attr : Ppthread_mutexattr_t; kind : integer):integer;
begin
  result := 0;
  if (attr <> nil)  and  (attr^ <> nil)  then
  begin
    case kind of
      Int(PTHREAD_MUTEX_FAST_NP),
      Int(PTHREAD_MUTEX_RECURSIVE_NP),
      Int(PTHREAD_MUTEX_ERRORCHECK_NP):
        attr^.kind := kind;

    else
      result := EINVAL;

    end;
  end
  else
     result := EINVAL;


end;

function pthread_mutexattr_setrobust( attr : Ppthread_mutexattr_t; robust : integer):integer;
begin
  result := EINVAL;
  if (attr <> nil)  and  (attr^ <> nil)  then
    begin
      case robust of
          Int(PTHREAD_MUTEX_STALLED),
          Int(PTHREAD_MUTEX_ROBUST):
          begin
            attr^.robustness := robust;
            result := 0;
          end;
      end;
    end;

end;

function pthread_mutexattr_setpshared( attr : Ppthread_mutexattr_t; pshared : integer):integer;
begin
  if (attr <> nil)  and  (attr^ <> nil)   and
      ((pshared = Int(PTHREAD_PROCESS_SHARED))  or
       (pshared = Int(PTHREAD_PROCESS_PRIVATE)))  then
    begin
      if pshared = Int(PTHREAD_PROCESS_SHARED) then
      begin
    {$IF not defined( _POSIX_THREAD_PROCESS_SHARED )}
        result := ENOSYS;
        pshared := Int(PTHREAD_PROCESS_PRIVATE);
    {$ELSE}
        result = 0;
    {$IFEND}
      end
      else
        result := 0;

      attr^.pshared := pshared;
  end
  else
     result := EINVAL;

end;

function pthread_mutexattr_setkind_np( attr : Ppthread_mutexattr_t; kind : integer):integer;
begin
  Result := pthread_mutexattr_settype (attr, kind);
end;

function pthread_mutexattr_init( attr : Ppthread_mutexattr_t):integer;
var

  ma : pthread_mutexattr_t;
begin
  result := 0;
  ma := pthread_mutexattr_t( calloc (1, sizeof (ma^)));
  if ma = nil then begin
      result := ENOMEM;
    end
  else
    begin
      ma.pshared := Int(PTHREAD_PROCESS_PRIVATE);
      ma.kind := Int(PTHREAD_MUTEX_DEFAULT);
      ma.robustness := Int(PTHREAD_MUTEX_STALLED);
    end;
  attr^ := ma;
  Result := (result);
end;

function pthread_mutexattr_gettype(const attr : Ppthread_mutexattr_t; kind : Pinteger):integer;
begin
  result := 0;
  if (attr <> nil)  and  (attr^ <> nil)  and  (kind <> nil) then
    kind^ := attr^.kind

  else

      result := EINVAL;
end;

function pthread_mutexattr_getrobust(const attr : Ppthread_mutexattr_t; robust : Pinteger):integer;
begin
  result := EINVAL;
  if (attr <> nil)  and  (attr^ <> nil)  and  (robust <> nil)  then
    begin
      robust^ := attr^.robustness;
      result := 0;
    end;

end;

function pthread_mutexattr_getpshared(const attr : Ppthread_mutexattr_t; pshared : Pinteger):integer;
begin
  if (attr <> nil)  and  (attr^ <> nil)   and  (pshared <> nil) then
  begin
    pshared^ := attr^.pshared;
    result := 0;
  end
  else
    result := EINVAL;


end;

function pthread_mutexattr_getkind_np( attr : Ppthread_mutexattr_t; kind : Pinteger):integer;
begin
  Result := pthread_mutexattr_gettype (attr, kind);
end;

function pthread_mutexattr_destroy( attr : Ppthread_mutexattr_t):integer;
var

  ma : pthread_mutexattr_t;
begin
  result := 0;
  if (attr = nil)  or  (attr^ = nil) then
      result := EINVAL

  else
  begin
    ma := attr^;
    attr^ := nil;
    free (ma);
  end;
  Result := (result);
end;

function pthread_mutex_unlock( mutex : Ppthread_mutex_t):integer;
var
  mx : pthread_mutex_t;
  kind : integer;
  idx : LONG;
  self : pthread_t;
begin
  mx := mutex^;
  result := 0;

  if (mx) < (PTHREAD_ERRORCHECK_MUTEX_INITIALIZER) then
  begin
      kind := mx.kind;
      if kind >= 0 then
      begin
          if kind = Int(PTHREAD_MUTEX_NORMAL) then
          begin
              idx := LONG(__PTW32_INTERLOCKED_EXCHANGE_LONG  (__PTW32_INTERLOCKED_LONGPTR(@mx.lock_idx)^,
                         __PTW32_INTERLOCKED_LONG(0)));
              if idx <> 0 then
              begin
                  if idx < 0 then
                  begin

                    if SetEvent (mx.event) = LongBool(0) then
                       result := EINVAL;

                  end;
              end;
          end
          else
          begin
            if pthread_equal (mx.ownerThread, pthread_self()) then
              begin
                Dec(mx.recursive_count);
                if (kind <> Int(PTHREAD_MUTEX_RECURSIVE)) or
                   (0 = mx.recursive_count) then
                begin
                  mx.ownerThread.p := nil;
                  if __PTW32_INTERLOCKED_EXCHANGE_LONG  (mx.lock_idx, 0) < 0 then
                  begin

                    if SetEvent (mx.event) = LongBool(0) then
                       result := EINVAL;

                  end;
                end;
              end
              else
                result := EPERM;

          end;
      end
      else
      begin

        self := pthread_self();
        kind := -kind - 1;

        if pthread_equal (mx.ownerThread, self) then
        begin
           __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG (__PTW32_INTERLOCKED_LONGPTR(@mx.robustNode.stateInconsistent)^,
                                                   __PTW32_INTERLOCKED_LONG(__PTW32_ROBUST_NOTRECOVERABLE),
                                                   __PTW32_INTERLOCKED_LONG(__PTW32_ROBUST_INCONSISTENT));
          if Int(PTHREAD_MUTEX_NORMAL) = kind then
          begin
              __ptw32_robust_mutex_remove(mutex, nil);
              if LONG ( __PTW32_INTERLOCKED_EXCHANGE_LONG (__PTW32_INTERLOCKED_LONGPTR(@mx.lock_idx)^,
                                                          __PTW32_INTERLOCKED_LONG(0))) < 0 then
                begin

                  if SetEvent (mx.event) = LongBool(0) then
                     result := EINVAL;

                end;
          end
          else
          begin
            Dec(mx.recursive_count);
            if (kind <> Int(PTHREAD_MUTEX_RECURSIVE)) or
                (  0 = mx.recursive_count)   then
              begin
                __ptw32_robust_mutex_remove(mutex, nil);
                if LONG ( __PTW32_INTERLOCKED_EXCHANGE_LONG (__PTW32_INTERLOCKED_LONGPTR(@mx.lock_idx)^,
                                                             __PTW32_INTERLOCKED_LONG( 0))) < 0 then
                begin

                  if SetEvent (mx.event) = LongBool(0) then
                     result := EINVAL;

                end;
              end;
          end;
        end
        else
          result := EPERM;

      end;
  end
  else
  if (mx) <> (PTHREAD_MUTEX_INITIALIZER) then
     result := EINVAL;

end;

function pthread_mutex_trylock( mutex : Ppthread_mutex_t):integer;
var
  mx       : pthread_mutex_t;
  kind, addend     : integer;
  self     : pthread_t;
  statePtr : __ptw32_robust_state_t;
begin
  mx := mutex^;
  result := 0;
  if mx = nil then begin
      Exit(EINVAL);
    end;
  if mx >= PTHREAD_ERRORCHECK_MUTEX_INITIALIZER then
  begin
      result := __ptw32_mutex_check_need_init (mutex);
      if Result <> 0 then
      begin
        Exit((result));
      end;
      mx := mutex^;
  end;
  kind := mx.kind;
  if kind >= 0 then
  begin

      if 0 =  __PTW32_INTERLOCKED_LONG(__PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG (
              mx.lock_idx,1,0))then

      begin
        if kind <> Int(PTHREAD_MUTEX_NORMAL) then
        begin
          mx.recursive_count := 1;
          mx.ownerThread := pthread_self ();
        end;
      end
      else
      begin
        if (kind = Int(PTHREAD_MUTEX_RECURSIVE))  and
           (pthread_equal (mx.ownerThread, pthread_self)) then
           Inc(mx.recursive_count)

        else
          result := EBUSY;

      end;
  end
  else
  begin
    statePtr := &mx.robustNode.stateInconsistent;
    addend := Int(statePtr);
    if __PTW32_INTERLOCKED_LONG( __PTW32_ROBUST_NOTRECOVERABLE) =
                 __PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(
                   Int(statePtr), 0) then
      begin
        Exit(ENOTRECOVERABLE);
      end;
    self := pthread_self();
    kind := -kind - 1;
    if 0 =  __PTW32_INTERLOCKED_LONG  (__PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG (
                  __PTW32_INTERLOCKED_LONGPTR( @mx.lock_idx)^,
                  __PTW32_INTERLOCKED_LONG( 1),
                  __PTW32_INTERLOCKED_LONG( 0)))  then
      begin
        if kind <> Int(PTHREAD_MUTEX_NORMAL) then
        begin
          mx.recursive_count := 1;
        end;
        __ptw32_robust_mutex_add(mutex, self);
      end
      else
      begin
        if (Int(PTHREAD_MUTEX_RECURSIVE )= kind ) and
           ( pthread_equal (mx.ownerThread, pthread_self)) then
        begin
          Inc(mx.recursive_count);
        end
        else
        begin
          result := __ptw32_robust_mutex_inherit(mutex);
          if EOWNERDEAD = Result then
          begin
            mx.recursive_count := 1;
            __ptw32_robust_mutex_add(mutex, self);
          end
          else
          begin
            if 0 = result then
              result := EBUSY;

          end;
        end;
      end;
  end;

end;


function __ptw32_relmillisecs(const abstime : Ptimespec):DWORD;
var
  milliseconds       : DWORD;
  tmpAbsNanoseconds,
  tmpCurrNanoseconds : int64;
  currSysTime        : timespec;
  ft                 : FILETIME;
  st                 : SYSTEMTIME;
  deltaNanoseconds   : int64;
begin
{$if defined(WINCE)}
   SYSTEMTIME st;
{$IFEND}
  tmpAbsNanoseconds := abstime.tv_nsec + (abstime.tv_sec * NANOSEC_PER_SEC);

{$if defined(WINCE)}
  GetSystemTime(&st);
  SystemTimeToFileTime(&st, &ft);
{$else }
  GetSystemTimeAsFileTime(&ft);
{$IFEND}
  __ptw32_filetime_to_timespec(@ft, @currSysTime);
  tmpCurrNanoseconds := currSysTime.tv_nsec + (currSysTime.tv_sec * NANOSEC_PER_SEC);
  if tmpAbsNanoseconds > tmpCurrNanoseconds then
  begin
      deltaNanoseconds := tmpAbsNanoseconds - tmpCurrNanoseconds;
      if deltaNanoseconds >= int64_t (INFINITE * NANOSEC_PER_MILLISEC) then
         milliseconds := INFINITE - 1

      else
         milliseconds := DWORD(deltaNanoseconds div NANOSEC_PER_MILLISEC);

  end
  else
     milliseconds := 0;

  if (milliseconds = 0)  and  (tmpAbsNanoseconds > tmpCurrNanoseconds) then
     milliseconds := 1;

  Result := milliseconds;
end;

function __ptw32_timed_eventwait(event : THANDLE;const abstime : Ptimespec):integer;
var
  milliseconds,
  status       : DWORD;
begin
  if Null = (event) then
      Exit(EINVAL)

  else
  begin
    if abstime = nil then
       milliseconds := INFINITE

    else
    begin

      milliseconds := __ptw32_relmillisecs (abstime);
    end;
    status := WaitForSingleObject (event, milliseconds);
    if status <> WAIT_OBJECT_0 then
    begin
        if status = WAIT_TIMEOUT then
           Exit(ETIMEDOUT)

        else
          Exit(EINVAL);

    end;
  end;
  Exit(0);
end;

function pthread_mutex_timedlock(mutex : Ppthread_mutex_t;const abstime : Ptimespec):integer;
var
  mx       : pthread_mutex_t;
  kind     : Integer;

  self     : pthread_t;
  statePtr : __ptw32_robust_state_t;
begin

  mx := mutex^;
  result := 0;
  if mx = nil then
      Exit(EINVAL);

  if mx >= PTHREAD_ERRORCHECK_MUTEX_INITIALIZER then
  begin
      result := __ptw32_mutex_check_need_init (mutex);
      if result  <> 0 then
         Exit((result));

      mx := mutex^;
  end;
  kind := mx.kind;
  if kind >= 0 then
  begin
      if mx.kind = Int(PTHREAD_MUTEX_NORMAL) then
      begin
          if __PTW32_INTERLOCKED_LONG(__PTW32_INTERLOCKED_EXCHANGE_LONG(
            __PTW32_INTERLOCKED_LONGPTR( @mx.lock_idx)^,
            __PTW32_INTERLOCKED_LONG( 1))) <> 0 then
          begin
              while __PTW32_INTERLOCKED_LONG( __PTW32_INTERLOCKED_EXCHANGE_LONG(
                               __PTW32_INTERLOCKED_LONGPTR( &mx.lock_idx)^,
                        __PTW32_INTERLOCKED_LONG( -1))) <> 0  do
              begin
                result := __ptw32_timed_eventwait (mx.event, abstime);
                if 0 <> Result then
                begin
                  Exit(result);
                end;
              end;
          end;
      end
      else
      begin
          self := pthread_self();
          if __PTW32_INTERLOCKED_LONG ( __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(
                        __PTW32_INTERLOCKED_LONGPTR( @mx.lock_idx)^,
            __PTW32_INTERLOCKED_LONG( 1),
            __PTW32_INTERLOCKED_LONG( 0))) = 0  then
          begin
            mx.recursive_count := 1;
            mx.ownerThread := self;
          end
          else
          begin
            if pthread_equal (mx.ownerThread, self) then
            begin
              if mx.kind = Int(PTHREAD_MUTEX_RECURSIVE) then
                 Inc(mx.recursive_count)
              else
                 Exit(EDEADLK);

            end
            else
            begin
              while __PTW32_INTERLOCKED_LONG (   __PTW32_INTERLOCKED_EXCHANGE_LONG(
                               __PTW32_INTERLOCKED_LONGPTR( @mx.lock_idx)^,
                      __PTW32_INTERLOCKED_LONG( -1))) <> 0 do
              begin
                result := __ptw32_timed_eventwait (mx.event, abstime);
                if 0 <> Result  then
                   Exit(result);

              end;
              mx.recursive_count := 1;
              mx.ownerThread := self;
            end;
          end;
      end;
  end
  else
    begin

      statePtr := &mx.robustNode.stateInconsistent;
      if __PTW32_INTERLOCKED_LONG (__PTW32_ROBUST_NOTRECOVERABLE )=  __PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(
                                                  int(statePtr),
                                                  __PTW32_INTERLOCKED_LONG(0)) then
      begin
        result := ENOTRECOVERABLE;
      end
      else
        begin
          self := pthread_self();
          kind := -kind - 1;
          if Int(PTHREAD_MUTEX_NORMAL) = kind then
          begin
              if __PTW32_INTERLOCKED_LONG (  __PTW32_INTERLOCKED_EXCHANGE_LONG(
                __PTW32_INTERLOCKED_LONGPTR(@mx.lock_idx)^,
                __PTW32_INTERLOCKED_LONG( 1))) <> 0   then
              begin
                 result := __ptw32_robust_mutex_inherit(mutex);
                 while (0 = result)  and
                       (__PTW32_INTERLOCKED_LONG(  __PTW32_INTERLOCKED_EXCHANGE_LONG(
                                                       __PTW32_INTERLOCKED_LONGPTR( @mx.lock_idx)^,
                                                      __PTW32_INTERLOCKED_LONG( -1)) ) <> 0
                       ) do
                 begin
                      result := __ptw32_timed_eventwait (mx.event, abstime);
                      if 0 <> Result then
                      begin
                        Exit(result);
                      end;
                      if __PTW32_INTERLOCKED_LONG (__PTW32_ROBUST_NOTRECOVERABLE) =
                                   __PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(
                                     int(statePtr),
                                     __PTW32_INTERLOCKED_LONG(0)) then
                        begin

                          SetEvent(mx.event);
                          result := ENOTRECOVERABLE;
                          break;
                        end;
                    result := __ptw32_robust_mutex_inherit(mutex);
                  end;
                  if (0 = result)  or  (EOWNERDEAD = result) then

                      __ptw32_robust_mutex_add(mutex, self);

              end;
          end
          else
          begin
              self := pthread_self();
              if 0 =  __PTW32_INTERLOCKED_LONG(  __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(
                            __PTW32_INTERLOCKED_LONGPTR( @mx.lock_idx)^,
                __PTW32_INTERLOCKED_LONG( 1),
                __PTW32_INTERLOCKED_LONG( 0))) then
              begin
                mx.recursive_count := 1;
                __ptw32_robust_mutex_add(mutex, self);
              end
              else
              begin
                  if pthread_equal (mx.ownerThread, self ) then
                  begin
                    if Int(PTHREAD_MUTEX_RECURSIVE) = kind then
                    begin
                      Inc(mx.recursive_count);
                    end
                    else
                    begin
                      Exit(EDEADLK);
                    end;
                  end
                  else
                  begin
                      result := __ptw32_robust_mutex_inherit(mutex);
                      while (0 = Result)
                                and  (__PTW32_INTERLOCKED_LONG(  __PTW32_INTERLOCKED_EXCHANGE_LONG(
                                           __PTW32_INTERLOCKED_LONGPTR(@mx.lock_idx)^,
                                           __PTW32_INTERLOCKED_LONG( -1))) <> 0) do
                      begin
                        result := __ptw32_timed_eventwait (mx.event, abstime );
                        if 0 <> Result then

                            Exit(result);

                        result := __ptw32_robust_mutex_inherit(mutex);
                      end;
                      if __PTW32_INTERLOCKED_LONG ( __PTW32_ROBUST_NOTRECOVERABLE )=
                                   __PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(
                                     int(statePtr),
                                     __PTW32_INTERLOCKED_LONG(0)) then
                        begin

                          SetEvent(mx.event);
                          result := ENOTRECOVERABLE;
                        end
                        else
                        if (0 = result)  or  (EOWNERDEAD = result) then
                        begin
                          mx.recursive_count := 1;

                          __ptw32_robust_mutex_add(mutex, self);
                        end;
                  end;
              end;
          end;
        end;
    end;

end;

function __ptw32_mutex_check_need_init( mutex : Ppthread_mutex_t):integer;
var

  mtx : pthread_mutex_t;
  node : __ptw32_mcs_local_node_t;
begin
   result := 0;
  __ptw32_mcs_lock_acquire(@__ptw32_mutex_test_init_lock, @node);

  mtx := mutex^;
  if mtx = PTHREAD_MUTEX_INITIALIZER then
      result := pthread_mutex_init (mutex, nil)

  else
  if (mtx = PTHREAD_RECURSIVE_MUTEX_INITIALIZER) then
     result := pthread_mutex_init (mutex, @__ptw32_recursive_mutexattr)

  else
  if (mtx = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER) then
     result := pthread_mutex_init (mutex, @__ptw32_errorcheck_mutexattr)

  else
  if (mtx = nil) then
     result := EINVAL;

  __ptw32_mcs_lock_release(@node);
  Result := (result);
end;

function pthread_mutex_lock( mutex : Ppthread_mutex_t):integer;
var
  mx       : pthread_mutex_t;
  kind     : Integer;
  addend   : Integer;
  self     : pthread_t;
  statePtr : __ptw32_robust_state_t;

begin

  mx := mutex^;
  result := 0;
  if mx = nil then
     Exit(EINVAL);

  if (mx) >= (PTHREAD_ERRORCHECK_MUTEX_INITIALIZER) then
  begin
      result := __ptw32_mutex_check_need_init (mutex);
      if result =  0 then
          Exit((result));

      mx := mutex^;
  end;
  kind := mx.kind;
  if kind >= 0 then
  begin

      if Int(PTHREAD_MUTEX_NORMAL) = kind then
      begin
        if __PTW32_INTERLOCKED_EXCHANGE_LONG(mx.lock_idx, 1) <> 0 then
        begin
           while __PTW32_INTERLOCKED_EXCHANGE_LONG(
                    mx.lock_idx,-1 ) <> 0 do
            begin
              if WAIT_OBJECT_0 <> WaitForSingleObject (mx.event, 0) then//INFINITE) then
              begin
                result := EINVAL;
                break;
              end;
            end;
        end;
      end
      else
      begin
          self := pthread_self();
          if __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(mx.lock_idx, 1, 0) = 0  then
          begin
            mx.recursive_count := 1;
            mx.ownerThread := self;
          end
          else
          begin
              if pthread_equal (mx.ownerThread, self) then
              begin
                if kind = Int(PTHREAD_MUTEX_RECURSIVE) then
                   Inc(mx.recursive_count)

                else
                   result := EDEADLK;

              end
              else
              begin
                while __PTW32_INTERLOCKED_EXCHANGE_LONG(mx.lock_idx, -1) <> 0  do
                begin
                   if WAIT_OBJECT_0 <> WaitForSingleObject (mx.event, INFINITE )  then
                    begin
                      result := EINVAL;
                      break;
                    end;
                end;
                if 0 = result then
                begin
                  mx.recursive_count := 1;
                  mx.ownerThread := self;
                end;
              end;
          end;
      end;
  end //if kind >= 0
  else
    begin

      statePtr := &mx.robustNode.stateInconsistent;
      addend := Int(statePtr);
      if Int(__PTW32_ROBUST_NOTRECOVERABLE)  =  __PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(
                                                         Integer(statePtr),0 ) then
      begin
        result := ENOTRECOVERABLE;
      end
      else
        begin
          self := pthread_self();
          kind := -kind - 1;
          if Int(PTHREAD_MUTEX_NORMAL) = kind then
          begin
              if __PTW32_INTERLOCKED_EXCHANGE_LONG(
                            mx.lock_idx, -1) <> 0 then
              begin
                result := __ptw32_robust_mutex_inherit(mutex);
                while (0 =  result) and
                      ( __PTW32_INTERLOCKED_EXCHANGE_LONG(mx.lock_idx, -1) <> 0) do
                begin
                  if WAIT_OBJECT_0 <> WaitForSingleObject (mx.event, INFINITE) then
                  begin
                    result := EINVAL;
                    break;
                  end;
                  if __PTW32_INTERLOCKED_LONG(  __PTW32_ROBUST_NOTRECOVERABLE) =
                               __PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(
                                 int(statePtr),
                                 __PTW32_INTERLOCKED_LONG(0))  then
                  begin

                    SetEvent(mx.event);
                    result := ENOTRECOVERABLE;
                    break;
                  end;
                  result := __ptw32_robust_mutex_inherit(mutex);
                end;
              end;
              if (0 = result)  or  (EOWNERDEAD = result) then
                  __ptw32_robust_mutex_add(mutex, self);

          end
          else
          begin
            if __PTW32_INTERLOCKED_LONG ( __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(
                          __PTW32_INTERLOCKED_LONGPTR( @mx.lock_idx)^,
                          __PTW32_INTERLOCKED_LONG( 1),
                          __PTW32_INTERLOCKED_LONG( 0))) = 0 then
              begin
                mx.recursive_count := 1;

                __ptw32_robust_mutex_add(mutex, self);
              end
              else
              begin
                if pthread_equal (mx.ownerThread, self) then
                begin
                  if Int(PTHREAD_MUTEX_RECURSIVE) = kind then
                     Inc(mx.recursive_count)
                  else
                     result := EDEADLK;

                end
                else
                begin
                  result := __ptw32_robust_mutex_inherit(mutex);
                  while ( 0 = Result)     and
                        (__PTW32_INTERLOCKED_LONG(  __PTW32_INTERLOCKED_EXCHANGE_LONG(
                                        __PTW32_INTERLOCKED_LONGPTR( @mx.lock_idx)^,
                                        __PTW32_INTERLOCKED_LONG( -1))) <> 0)  do
                  begin
                    if WAIT_OBJECT_0 <> WaitForSingleObject (mx.event, 0) then//INFINITE ) then
                    begin
                      result := EINVAL;
                      break;
                    end;
                    if __PTW32_INTERLOCKED_LONG  (__PTW32_ROBUST_NOTRECOVERABLE) =
                                 __PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(
                                   int(statePtr),
                                   __PTW32_INTERLOCKED_LONG(0))  then
                      begin

                        SetEvent(mx.event);
                        result := ENOTRECOVERABLE;
                        break;
                      end;
                      result := __ptw32_robust_mutex_inherit(mutex);
                  end;
                  if (0 = result)  or  (EOWNERDEAD = result) then
                  begin
                      mx.recursive_count := 1;

                      __ptw32_robust_mutex_add(mutex, self);
                  end;
                end;
              end;
          end;
        end;
    end;

end;

procedure __ptw32_set_errno( err : integer);
begin
    _set_errno(err);
    SetLastError(err);
end;




procedure __ptw32_mcs_node_transfer( new_node, old_node : __Pptw32_mcs_local_node_t);
begin
  new_node.lock := old_node.lock;
  new_node.nextFlag := 0;
  new_node.readyFlag := 0;
  new_node.next := nil;
  if __Pptw32_mcs_local_node_t (__PTW32_INTERLOCKED_COMPARE_EXCHANGE_PTR (__PTW32_INTERLOCKED_PVOID_PTR (new_node.lock)^,
                                                                          __PTW32_INTERLOCKED_PVOID(new_node),
                                                                          __PTW32_INTERLOCKED_PVOID(old_node)))
       <> old_node then
    begin

      while nil = old_node.next do
      begin
        sched_yield();
      end;

      __ptw32_mcs_flag_wait(old_node.nextFlag);

      new_node.next := old_node.next;
      new_node.nextFlag := old_node.nextFlag;
    end;
end;

procedure __ptw32_mcs_lock_acquire( Alock : __Pptw32_mcs_lock_t; node: __Pptw32_mcs_local_node_t);
var
  pred : __Pptw32_mcs_local_node_t;
  p1, p2: PPointer;
begin
  node.lock := Alock;
  node.nextFlag := 0;
  node.readyFlag := 0;
  node.next := nil;

  p1 := PPointer(Alock);
  pred := __Pptw32_mcs_local_node_t (__PTW32_INTERLOCKED_EXCHANGE_PTR (p1,//__PTW32_INTERLOCKED_PVOID_PTR(lock),
                                           node)); //__PTW32_INTERLOCKED_PVOID(node)));
  if nil <> pred then
  begin
      p2 := PPointer(@pred.next);
      __PTW32_INTERLOCKED_EXCHANGE_PTR (p2, //__PTW32_INTERLOCKED_PVOID_PTR(@pred.next),
                                        node);// __PTW32_INTERLOCKED_PVOID(node));
      __ptw32_mcs_flag_set(pred.nextFlag);
      __ptw32_mcs_flag_wait(node.readyFlag);
  end;
end;

function __ptw32_semwait( sem : Psem_t):integer;
var
  node : __ptw32_mcs_local_node_t;
  v : integer;
  s : sem_t;
begin
  result := 0;
  s := sem^;
  __ptw32_mcs_lock_acquire(@s.lock, @node);
  Dec(s.value);
  v := s.value;
  __ptw32_mcs_lock_release(@node);
  if v < 0 then
  begin

      if WaitForSingleObject (s.sem, INFINITE) = WAIT_OBJECT_0 then
        begin
{$IF defined(NEED_SEM)}
          __ptw32_mcs_lock_acquire(&s.lock, &node);
          if s.leftToUnblock > 0 then
          begin
              Dec(s.leftToUnblock);
              SetEvent(s.sem);
          end;
          __ptw32_mcs_lock_release(&node);
{$IFEND}
Exit(0);
        end;
  end
  else
    Exit(0);

  if result <> 0 then
  begin
       __PTW32_SET_ERRNO(result);
      Exit(-1);
  end;
  Exit(0);
end;

function pthread_barrier_wait( barrier : Ppthread_barrier_t):integer;
var
  //result : integer;
  b : pthread_barrier_t;
  node : __ptw32_mcs_local_node_t;
begin
  if (barrier = nil)  or  (barrier^ = pthread_barrier_t( __PTW32_OBJECT_INVALID) ) then
    begin
      Exit(EINVAL);
    end;
  __ptw32_mcs_lock_acquire(@barrier^.lock, @node);
  b := barrier^;
  if PreDec(b.nCurrentBarrierHeight) = 0  then
  begin

    __ptw32_mcs_node_transfer(@b.proxynode, @node);

    if (b.nInitialBarrierHeight > 1) then
        result :=  sem_post_multiple (@b.semBarrierBreeched, b.nInitialBarrierHeight - 1)
    else
        Result:= 0;
  end
  else
  begin
    __ptw32_mcs_lock_release(@node);

    result := __ptw32_semwait(@b.semBarrierBreeched);
  end;
  if __PTW32_INTERLOCKED_LONG(__PTW32_INTERLOCKED_INCREMENT_LONG (__PTW32_INTERLOCKED_LONGPTR(@b.nCurrentBarrierHeight)^))
      =  __PTW32_INTERLOCKED_LONG(b.nInitialBarrierHeight)  then
    begin

      __ptw32_mcs_lock_release(@b.proxynode);
      if 0 = result then
          result := Int(PTHREAD_BARRIER_SERIAL_THREAD);

    end;
  //Result := (result);
end;

function pthread_barrierattr_setpshared( attr : Ppthread_barrierattr_t; pshared : integer):integer;
begin
  if (attr <> nil)  and  (attr^ <> nil)  and
      ((pshared = Int(PTHREAD_PROCESS_SHARED))  or
       (pshared = Int(PTHREAD_PROCESS_PRIVATE))) then
  begin
      if pshared = Int(PTHREAD_PROCESS_SHARED) then
      begin
    {$IF not defined( _POSIX_THREAD_PROCESS_SHARED )}
        result := ENOSYS;
        pshared := Int(PTHREAD_PROCESS_PRIVATE);
    {$ELSE} result = 0;
    {$IFEND}
      end
      else
      begin
        result := 0;
      end;
      attr^.pshared := pshared;
  end
  else
  begin
    result := EINVAL;
  end;
  Exit((result));
end;

function pthread_barrierattr_init( attr : Ppthread_barrierattr_t):integer;
var
  ba : pthread_barrierattr_t;
  //result : integer;
begin
  result := 0;
  ba := pthread_barrierattr_t( calloc (1, sizeof ( ba^)));
  if ba = nil then
     result := ENOMEM
  else
     ba.pshared := Int(PTHREAD_PROCESS_PRIVATE);

  attr^ := ba;

end;

function pthread_barrierattr_getpshared(const attr : Ppthread_barrierattr_t; pshared : Pinteger):integer;
begin
  if (attr <> nil)  and  (attr^ <> nil) and  (pshared <> nil) then
    begin
      pshared^ := attr^.pshared;
      result := 0;
    end
    else
    begin
      result := EINVAL;
    end;
  Result := (result);
end;

function pthread_barrierattr_destroy( attr : Ppthread_barrierattr_t):integer;
var
  //result : integer;
  ba : pthread_barrierattr_t;
begin
  result := 0;
  if (attr = nil)  or  (attr^ = nil) then
  begin
      result := EINVAL;
  end
  else
  begin
    ba := attr^;
    attr^ := nil;
    free (ba);
  end;
  //Result := (result);
end;

procedure __ptw32_throw( Aexception : DWORD);
var
  sp                   : __Pptw32_thread_t;
  {$IF defined(__PTW32_CLEANUP_SEH)}

  exceptionInformation : array[0..2] of DWORD;
  {$IFEND}
  exitCode             : UInt32;
begin

  sp := __Pptw32_thread_t (pthread_getspecific (__ptw32_selfThreadKey));

  sp.state := PThreadStateExiting;
  if (Aexception <>  __PTW32_EPS_CANCEL ) and  (Aexception <>  __PTW32_EPS_EXIT) then
      halt (1);

  if (nil = sp)  or  (sp.implicit>0) then
  begin

{$IF not  defined (__MINGW32__)  or  defined (__MSVCRT__)  or  defined (__DMC__)}
      exitCode := 0;
      case Aexception of
          __PTW32_EPS_CANCEL:
          exitCode := uint32((size_t(PTHREAD_CANCELED)));
          //break;
          __PTW32_EPS_EXIT:
          if nil <> sp then begin
            exitCode := uint32(size_t(sp.exitStatus));
            end;
          //break;
        end;
{$IFEND}
{$IF defined (__PTW32_STATIC_LIB)}
      pthread_win32_thread_detach_np ();
{$IFEND}
{$IF defined (__MSVCRT__)  and not  defined (FPC)}
    {$if CompilerVersion <= 23}
      endthread (exitCode);
    {$ELSE}
      _endthreadex (exitCode);
    {$IFEND}
{$ELSE}
    endthread ();
{$IFEND}
 end;
{$IF defined(__PTW32_CLEANUP_SEH)}
  exceptionInformation[0] := (DWORD) (exception);
  exceptionInformation[1] := (DWORD) (0);
  exceptionInformation[2] := (DWORD) (0);
  RaiseException (EXCEPTION_PTW32_SERVICES, 0, 3, (ULONG_PTR *) exceptionInformation);
{$ELSE }
{$IF defined(__PTW32_CLEANUP_C)}
  __ptw32_pop_cleanup_all (1);
  longjmp (sp.start_mark, exception);
{$ELSE }
{$IF defined(__PTW32_CLEANUP_CXX)}
  case exception of
    __PTW32_EPS_CANCEL:
      throw __ptw32_exception_cancel ();
      break;
    __PTW32_EPS_EXIT:
      throw __ptw32_exception_exit ();
      break;
    end;
{$ELSE}
   raise exception.Create(' Cleanup type undefined.');
{$IFEND}  (* __PTW32_CLEANUP_CXX *)
{$IFEND}  (* __PTW32_CLEANUP_C *)
{$IFEND}  (* __PTW32_CLEANUP_SEH *)

end;


procedure __ptw32_pop_cleanup_all( execute : integer);
begin
  while nil <> __ptw32_pop_cleanup (execute) do
    begin
    end;
end;


function __ptw32_get_exception_services_code:DWORD;
begin
{$IF defined(__PTW32_CLEANUP_SEH)}
  Exit(EXCEPTION_PTW32_SERVICES);
{$ELSE}
  Exit(DWORD(0));
{$IFEND}
end;

procedure __ptw32_cancel_self;
begin
  __ptw32_throw(__PTW32_EPS_CANCEL);
end;


function __ptw32_Registercancellation( unused1 : PAPCFUNC; threadH : THANDLE; unused2 : DWORD):DWORD;
var
  context : TCONTEXT;
  s: string;
  P: ^DWORD_PTR;
begin
  context.ContextFlags := CONTEXT_CONTROL;
  GetThreadContext (threadH, &context);
  //s := Format('%p', [Addr(__ptw32_cancel_self)]);
  P := Addr(__ptw32_cancel_self);
   __PTW32_PROGCTR (context, P^);
  SetThreadContext (threadH, &context);
  Result := 0;
end;

procedure __ptw32_cancel_callback( unused : ULONG_PTR);
begin
  __ptw32_throw(__PTW32_EPS_CANCEL);

end;

function pthread_cancel( thread : pthread_t):integer;
var

  cancel_self : integer;
  self        : pthread_t;
  stateLock   : __ptw32_mcs_local_node_t;
  threadH     : THANDLE;
  tp:  __Pptw32_thread_t;
begin
  
  result := pthread_kill (thread, 0);
  if 0 <> result then
      Exit(result);

  self := pthread_self ;
  if self.p = nil then
     Exit(ENOMEM);



  cancel_self := Int(pthread_equal (thread, self));
  tp := __Pptw32_thread_t( thread.p);

  __ptw32_mcs_lock_acquire (@tp.stateLock, @stateLock);
  if (tp.cancelType = Int(PTHREAD_CANCEL_ASYNCHRONOUS))  and
     (tp.cancelState = Int(PTHREAD_CANCEL_ENABLE))  and
     (tp.state < PThreadStateCanceling) then
  begin
      if cancel_self>0 then
      begin
        tp.state := PThreadStateCanceling;
        tp.cancelState := Int(PTHREAD_CANCEL_DISABLE);
        __ptw32_mcs_lock_release (@stateLock);
        __ptw32_throw  (__PTW32_EPS_CANCEL);

      end
      else
      begin
          threadH := tp.threadH;
          SuspendThread (threadH);
          if WaitForSingleObject (threadH, 0)   = WAIT_TIMEOUT then
          begin
            tp.state := PThreadStateCanceling;
            tp.cancelState := Int(PTHREAD_CANCEL_DISABLE);

            __ptw32_register_cancellation^(PAPCFUNC(@__ptw32_cancel_callback), threadH, 0);
            __ptw32_mcs_lock_release (@stateLock);
            ResumeThread (threadH);
          end;
      end;
  end
  else
  begin

      if tp.state < PThreadStateCancelPending then
      begin
          tp.state := PThreadStateCancelPending;
          if  not SetEvent (tp.cancelEvent) then
              result := ESRCH;

      end
      else
      if (tp.state >= PThreadStateCanceling) then
         result := ESRCH;

      __ptw32_mcs_lock_release (@stateLock);
  end;

end;

function pthread_cond_destroy( cond : Ppthread_cond_t):integer;
var
  cv : pthread_cond_t;
  result0, result1, result2, tmp : integer;
  node : __ptw32_mcs_local_node_t;
begin
  result0 := 0; result1 := 0; result2 := 0;

  if (cond = nil)  or  (cond^ = nil) then
      Exit(EINVAL);

  if cond^ <> PTHREAD_COND_INITIALIZER then
  begin
      __ptw32_mcs_lock_acquire(@__ptw32_cond_list_lock, @node);
      cv := cond^;

      if __ptw32_semwait (@cv.semBlockLock) <> 0  then
      begin
        result0 := __PTW32_GET_ERRNO();
      end
      else
      begin
          result0 := pthread_mutex_trylock (@cv.mtxUnblockLock);
          if result0  <> 0 then
          begin
            sem_post (@cv.semBlockLock);
          end;
      end;
      if result0 <> 0 then
      begin
          __ptw32_mcs_lock_release(@node);
          Exit(result);
      end;

      if cv.nWaitersBlocked > cv.nWaitersGone then
      begin
        if sem_post (@cv.semBlockLock) <> 0 then
          begin
            result := __PTW32_GET_ERRNO();
          end;
        result1 := pthread_mutex_unlock (@cv.mtxUnblockLock);
        result2 := EBUSY;
      end
      else
      begin

          cond^ := nil;
          if sem_destroy (@cv.semBlockLock ) <> 0  then
             result0 := __PTW32_GET_ERRNO();

          if sem_destroy (@cv.semBlockQueue) <> 0 then
             result1 := __PTW32_GET_ERRNO();

          result2 := pthread_mutex_unlock (@cv.mtxUnblockLock );
          if result2 = 0 then
             result2 := pthread_mutex_destroy (@cv.mtxUnblockLock);


          if __ptw32_cond_list_head = cv then
              __ptw32_cond_list_head := cv.next

          else
              cv.prev.next := cv.next;

          if __ptw32_cond_list_tail = cv then
              __ptw32_cond_list_tail := cv.prev

          else
             cv.next.prev := cv.prev;

          free (cv);
      end;
      __ptw32_mcs_lock_release(@node);
  end
  else
  begin

    __ptw32_mcs_lock_acquire(@__ptw32_cond_test_init_lock, @node);

    if cond^ = PTHREAD_COND_INITIALIZER then
       cond^ := nil
    else
      result0 := EBUSY;

      __ptw32_mcs_lock_release(@node);
  end;
  if result1 <> 0 then
     tmp := result1
  else
     tmp := result2;
  if (result0 <> 0) then
     Result := result0
  else
     Result := tmp;
end;

function __ptw32_cond_unblock( cond : Ppthread_cond_t; unblockAll : integer):integer;
var

  cv              : pthread_cond_t;
  nSignalsToIssue : integer;
begin
  if (cond = nil)  or  (cond^ = nil) then begin
      Exit(EINVAL);
    end;
  cv := cond^;

  if cv = PTHREAD_COND_INITIALIZER then begin
      Exit(0);
    end;
  result := pthread_mutex_lock (@cv.mtxUnblockLock);
  if result <> 0 then
    begin
      Exit(result);
    end;
  if 0 <> cv.nWaitersToUnblock then
  begin
      if 0 = cv.nWaitersBlocked then
      begin
        Exit(pthread_mutex_unlock (@cv.mtxUnblockLock));
      end;
      if unblockAll>0 then
      begin
        nSignalsToIssue := cv.nWaitersBlocked;
        cv.nWaitersToUnblock  := cv.nWaitersToUnblock + nSignalsToIssue;
        cv.nWaitersBlocked := 0;
      end
      else
      begin
        nSignalsToIssue := 1;
        Inc(cv.nWaitersToUnblock);
        Dec(cv.nWaitersBlocked);
      end;
  end
  else
  if (cv.nWaitersBlocked > cv.nWaitersGone) then
  begin

    if __ptw32_semwait (@cv.semBlockLock ) <> 0 then
    begin
      result := __PTW32_GET_ERRNO();
      pthread_mutex_unlock (@cv.mtxUnblockLock);
      Exit(result);
    end;
    if 0 <> cv.nWaitersGone then
    begin
      cv.nWaitersBlocked  := cv.nWaitersBlocked - cv.nWaitersGone;
      cv.nWaitersGone := 0;
    end;
    if unblockAll>0 then
    begin
      nSignalsToIssue := cv.nWaitersBlocked;
      cv.nWaitersToUnblock := cv.nWaitersBlocked;
      cv.nWaitersBlocked := 0;
    end
    else
    begin
      nSignalsToIssue := 1;
      cv.nWaitersToUnblock := 1;
      Dec(cv.nWaitersBlocked);
    end;
  end
  else
    begin
      Exit(pthread_mutex_unlock (@cv.mtxUnblockLock));
    end;
  result := pthread_mutex_unlock (@cv.mtxUnblockLock);
  if Result = 0 then
  begin
    if sem_post_multiple (@cv.semBlockQueue, nSignalsToIssue) <> 0 then
    begin
      result := __PTW32_GET_ERRNO();
    end;
  end;
  Exit(result);
end;


function pthread_cond_signal( cond : Ppthread_cond_t):integer;
begin

  Exit((__ptw32_cond_unblock (cond, 0)));
end;


function pthread_cond_broadcast( cond : Ppthread_cond_t):integer;
begin

  Exit(__ptw32_cond_unblock (cond,  Int(__PTW32_TRUE)));
end;

procedure __ptw32_cond_wait_cleanup(args: Pointer);
var
  cleanup_args    : __Pptw32_cond_wait_cleanup_args_t;
  cv              : pthread_cond_t;
  resultPtr       : Pinteger;
  nSignalsWasLeft,
  result          : integer;
begin
  cleanup_args :=  __Pptw32_cond_wait_cleanup_args_t( args);
  cv := cleanup_args.cv;
  resultPtr := cleanup_args.resultPtr;
  result := pthread_mutex_lock (@cv.mtxUnblockLock );
  if result <> 0 then
  begin
    resultPtr^ := result;
    exit;
  end;
  nSignalsWasLeft := cv.nWaitersToUnblock;
  if 0 <> nSignalsWasLeft then
  begin
    dec(cv.nWaitersToUnblock);
  end
  else
  begin
    inc(cv.nWaitersGone);
    if (INT_MAX div 2 = (cv.nWaitersGone)) then
    begin

      if __ptw32_semwait (@cv.semBlockLock ) <> 0 then
      begin
        resultPtr^ :=  __PTW32_GET_ERRNO();
        Exit;
      end;
      cv.nWaitersBlocked  := cv.nWaitersBlocked - cv.nWaitersGone;
      if sem_post (@cv.semBlockLock) <> 0  then
      begin
        resultPtr^ :=  __PTW32_GET_ERRNO();
        Exit;
      end;
      cv.nWaitersGone := 0;
    end;
  end;
  result := pthread_mutex_unlock (@cv.mtxUnblockLock );
  if result  <> 0 then
  begin
    resultPtr^ := result;
    exit;
  end;
  if 1 = nSignalsWasLeft then
  begin
      if sem_post (@cv.semBlockLock) <> 0 then
      begin
        resultPtr^ :=  __PTW32_GET_ERRNO();
        exit;
      end;
  end;
  result := pthread_mutex_lock (cleanup_args.mutexPtr );
  if result <> 0 then
     resultPtr^ := result;

end;


procedure pthread_cleanup_pop( _execute: Integer );
begin
   __ptw32_pop_cleanup( _execute );
end;

function __ptw32_pop_cleanup( execute : integer): P__ptw32_cleanup_t;
var
  cleanup : P__ptw32_cleanup_t;
begin
  cleanup := P__ptw32_cleanup_t ( pthread_getspecific (__ptw32_cleanupKey));
  if cleanup <> nil then
  begin
      if (execute > 0) and  (cleanup.routine <> nil) then
      begin
         cleanup.routine^ (cleanup.arg);
      end;
      pthread_setspecific (__ptw32_cleanupKey, Pointer( cleanup.prev));
  end;
  Exit(cleanup);
end;


procedure __ptw32_push_cleanup( cleanup : P__ptw32_cleanup_t; routine : __ptw32_cleanup_callback_t; arg : Pointer);
begin
  cleanup.routine := routine;
  cleanup.arg := arg;
  cleanup.prev := P__ptw32_cleanup_t ( pthread_getspecific (__ptw32_cleanupKey));
  pthread_setspecific (__ptw32_cleanupKey, Pointer( cleanup));
end;

//__ptw32_cleanup_callback_t is a method pointer
procedure pthread_cleanup_push(_rout, _arg: Pointer );
var
  _cleanup: __ptw32_cleanup_t;
begin
   __ptw32_push_cleanup(@_cleanup, __ptw32_cleanup_callback_t(_rout), _arg );
end;

function __ptw32_cond_timedwait(cond : Ppthread_cond_t; mutex : Ppthread_mutex_t; abstime : Ptimespec):integer;
var

  cv           : pthread_cond_t;
  cleanup_args : __ptw32_cond_wait_cleanup_args_t;
begin
  result := 0;
  if (cond = nil)  or  (cond^ = nil) then begin
      Exit(EINVAL);
    end;

  if cond^ = PTHREAD_COND_INITIALIZER then
     result := __ptw32_cond_check_need_init (cond);

  if (result <> 0)  and  (result <> EBUSY) then
     Exit(result);

  cv := cond^;

  if sem_wait (@cv.semBlockLock ) <> 0 then
    begin
      Exit(__PTW32_GET_ERRNO());
    end;
  inc(cv.nWaitersBlocked);
  if sem_post (@cv.semBlockLock ) <> 0 then
    begin
      Exit(__PTW32_GET_ERRNO());
    end;

  cleanup_args.mutexPtr := mutex;
  cleanup_args.cv := cv;
  cleanup_args.resultPtr := @result;

  pthread_cleanup_push(@__ptw32_cond_wait_cleanup, Pointer(@cleanup_args));
  result := pthread_mutex_unlock (mutex);
  if result =  0 then
  begin
    if sem_timedwait (@cv.semBlockQueue, abstime) <> 0 then
    begin
      result := __PTW32_GET_ERRNO();
    end;
  end;

  pthread_cleanup_pop (1);

  Exit(result);
end;


function pthread_cond_wait(cond: Ppthread_cond_t; mutex: Ppthread_mutex_t): Integer;
begin

  Exit((__ptw32_cond_timedwait (cond, mutex, nil)));
end;


function pthread_cond_timedwait(cond : Ppthread_cond_t; mutex : Ppthread_mutex_t;const abstime : Ptimespec):integer;
begin
  if abstime = nil then begin
      Exit(EINVAL);
    end;
  Exit((__ptw32_cond_timedwait (cond, mutex, abstime)));
end;

function pthread_condattr_destroy( attr : Ppthread_condattr_t):integer;

begin
  result := 0;
  if (attr = nil)  or  (attr = nil) then
      result := EINVAL

  else
  begin
    free ( attr^);
    attr^ := nil;
    result := 0;
  end;
  Exit(result);
end;

function pthread_condattr_getpshared(const attr : Ppthread_condattr_t; pshared : Pinteger):integer;
begin
  if (attr <> nil)  and  (attr^ <> nil)   and  (pshared <> nil) then
  begin
    pshared^ :=  attr^.pshared;
    result := 0;
  end
  else
    begin
      result := EINVAL;
    end;
  Exit(result);
end;

function pthread_condattr_init( attr : Ppthread_condattr_t):integer;
var
  attr_result : pthread_condattr_t;

begin
  result := 0;
  attr_result := pthread_condattr_t( calloc (1, sizeof ( attr_result^)));
  if attr_result = nil then begin
      result := ENOMEM;
    end;
  attr^ := attr_result;
  Exit(result);
end;

function pthread_condattr_setpshared( attr : Ppthread_condattr_t; pshared : integer):integer;
begin
  if (attr <> nil)  and  (attr^ <> nil)  and
     ( (pshared = Int(PTHREAD_PROCESS_SHARED) ) or
       (pshared = Int(PTHREAD_PROCESS_PRIVATE))) then
  begin
      if pshared = Int(PTHREAD_PROCESS_SHARED) then
      begin
    {$IF not defined( _POSIX_THREAD_PROCESS_SHARED )}
        result := ENOSYS;
        pshared := Int(PTHREAD_PROCESS_PRIVATE);
    {$ELSE} result = 0;
    {$IFEND}
      end
      else
      begin
        result := 0;
      end;
      attr^.pshared := pshared;
  end
  else
    begin
      result := EINVAL;
    end;
  Exit(result);
end;

function pthread_delay_np( interval : Ptimespec):integer;
var
  wait_time,
  secs_in_millisecs,
  millisecs,
  status            : DWORD;
  self              : pthread_t;
  sp                : __Pptw32_thread_t;
  stateLock         : __ptw32_mcs_local_node_t;
begin
  if interval = nil then
      Exit(EINVAL);

  if (interval.tv_sec = 0)  and  (interval.tv_nsec = 0) then
  begin
      pthread_testcancel ();
      Sleep (0);
      pthread_testcancel ();
      Exit((0));
    end;

  secs_in_millisecs := DWORD(interval.tv_sec * 1000);

  millisecs := (interval.tv_nsec + 999999) div 1000000;
{$IF defined(__WATCOMC__)}
#pragma disable_message (124)
{$IFEND}
  wait_time := secs_in_millisecs + millisecs;
  if 0 >= ( wait_time )then
    begin
      Exit(EINVAL);
    end;
{$IF defined(__WATCOMC__)}
#pragma enable_message (124)
{$IFEND}
  self := pthread_self();
  if nil = self.p then
    begin
      Exit(ENOMEM);
    end;
  sp := __Pptw32_thread_t ( self.p);
  if sp.cancelState = Int(PTHREAD_CANCEL_ENABLE) then
  begin
      status := WaitForSingleObject (sp.cancelEvent, wait_time);
      if (WAIT_OBJECT_0 = status) then
      begin

        __ptw32_mcs_lock_acquire (@sp.stateLock, @stateLock);
        if sp.state < PThreadStateCanceling then
        begin
            sp.state := PThreadStateCanceling;
            sp.cancelState := Int(PTHREAD_CANCEL_DISABLE);
            __ptw32_mcs_lock_release (@stateLock);
            __ptw32_throw  (__PTW32_EPS_CANCEL);
          end;
        __ptw32_mcs_lock_release (@stateLock);
        Exit(ESRCH);
      end
      else
      if (status <> WAIT_TIMEOUT) then
      begin
        Exit(EINVAL);
      end;
  end
  else
     Sleep (wait_time);

  Result := (0);
end;

function __ptw32_threadReusePop:pthread_t;
var
  t : pthread_t;
  node : __ptw32_mcs_local_node_t;
  tp: __Pptw32_thread_t;
begin
  t.p := nil;
  t.x := 0;

  __ptw32_mcs_lock_acquire(@__ptw32_thread_reuse_lock, @node);
  if __PTW32_THREAD_REUSE_EMPTY <> __ptw32_threadReuseTop then
  begin

      tp := __ptw32_threadReuseTop;
      __ptw32_threadReuseTop := tp.prevReuse;
      if __PTW32_THREAD_REUSE_EMPTY = __ptw32_threadReuseTop then
          __ptw32_threadReuseBottom := __PTW32_THREAD_REUSE_EMPTY;

      tp.prevReuse := nil;
      t := tp.ptHandle;
  end;
  __ptw32_mcs_lock_release(@node);
  Result := t;
end;

procedure __ptw32_threadReusePush( thread : pthread_t);
var
  tp : __Pptw32_thread_t;
  t : pthread_t;
  node : __ptw32_mcs_local_node_t;
begin
  tp := __Pptw32_thread_t ( thread.p);
  //add by softwind 2021.12.23
  if tp = nil then
     exit;
  __ptw32_mcs_lock_acquire(@__ptw32_thread_reuse_lock, @node);
  t := tp.ptHandle;
  memset(tp, 0, sizeof(__ptw32_thread_t));

  tp.ptHandle := t;

{$IF defined (__PTW32_THREAD_ID_REUSE_INCREMENT)}
  tp.ptHandle.x  := tp.ptHandle.x + __PTW32_THREAD_ID_REUSE_INCREMENT;
{$ELSE tp.ptHandle.PostInc(x);}
{$IFEND}
  tp.state := PThreadStateReuse;
  tp.prevReuse := __PTW32_THREAD_REUSE_EMPTY;
  if __PTW32_THREAD_REUSE_EMPTY <> __ptw32_threadReuseBottom then
      __ptw32_threadReuseBottom.prevReuse := tp

  else
     __ptw32_threadReuseTop := tp;

  __ptw32_threadReuseBottom := tp;
  __ptw32_mcs_lock_release(@node);
end;

procedure __ptw32_threadDestroy( thread : pthread_t);
var
  tp          : __Pptw32_thread_t;
  threadH,
  cancelEvent : THANDLE;
begin
  tp := __Pptw32_thread_t ( thread.p);
  if tp <> nil then
  begin

{$IF not  defined(__MINGW32__)  or  defined (__MSVCRT__)  or  defined (__DMC__)}
      threadH := tp.threadH;
{$IFEND}
      cancelEvent := tp.cancelEvent;

      __ptw32_threadReusePush (thread);
      if Null<>(cancelEvent) then
      begin
        CloseHandle (cancelEvent);
      end;
{$IF not  defined(__MINGW32__)  or  defined (__MSVCRT__)  or  defined (__DMC__)}

      if threadH <> 0 then
         CloseHandle (threadH);

{$IFEND}
end;
end;

function pthread_detach( thread : pthread_t):integer;
var

  destroyIt : Byte;
  tp        : __Pptw32_thread_t;
  reuseLock,
  stateLock : __ptw32_mcs_local_node_t;
begin
  destroyIt := Int(__PTW32_FALSE);
  tp := __Pptw32_thread_t ( thread.p);
  __ptw32_mcs_lock_acquire(@__ptw32_thread_reuse_lock, @reuseLock);
  if (nil = tp ) or  (thread.x <> tp.ptHandle.x) then
      result := ESRCH

  else
  if int(PTHREAD_CREATE_DETACHED)  = tp.detachState then
     result := EINVAL

  else
  begin

    result := 0;
    __ptw32_mcs_lock_acquire (@tp.stateLock, @stateLock);
    if tp.state < PThreadStateLast then
    begin
        tp.detachState := Int(PTHREAD_CREATE_DETACHED);
        if tp.state = PThreadStateExiting then
          destroyIt := Int(__PTW32_TRUE);

    end
    else
    if (tp.detachState <> Int(PTHREAD_CREATE_DETACHED)) then
       destroyIt := Int(__PTW32_TRUE);

    __ptw32_mcs_lock_release (@stateLock);
  end;
  __ptw32_mcs_lock_release(@reuseLock);
  if result = 0 then
  begin

      if destroyIt>0 then
      begin

        WaitForSingleObject(tp.threadH, INFINITE);
        __ptw32_threadDestroy (thread);
      end;
  end;
  Exit((result));
end;

function pthread_equal( t1, t2 : pthread_t):Boolean;
begin
  if ( __Pptw32_thread_t(t1.p) = __Pptw32_thread_t(t2.p) )  and  (t1.x = t2.x ) then
     result := True
  else
    result := False;
end;

procedure pthread_exit( value_ptr : Pointer);
var
  sp: __Pptw32_thread_t;
begin

  sp := __Pptw32_thread_t( pthread_getspecific (__ptw32_selfThreadKey));
{$IF defined(_UWIN)}
  if PreDec(pthread_count then <= 0)
    exit ((int) value_ptr);
{$IFEND}
  if nil = sp then
  begin

{$IF defined (__MSVCRT__)   and not  defined (FPC)}
    {$if CompilerVersion <= 23}
      endthread (uint32( (size_t(value_ptr))));
    {$ELSE}
      _endthreadex (uint32( (size_t(value_ptr))));
    {$IFEND}
{$ELSE}
  endthread ();
{$IFEND}

end;
  sp.exitStatus := value_ptr;
  __ptw32_throw  (__PTW32_EPS_EXIT);

end;

function pthread_getconcurrency:integer;
begin
  Result := __ptw32_concurrency;
end;

function pthread_getname_np( thr : pthread_t; name : Pchar; len : integer):integer;
var
  threadLock : __ptw32_mcs_local_node_t;
  tp         : __Pptw32_thread_t;
  s,
  d          : Pchar;

begin

  result := pthread_kill (thr, 0);
  if 0 <> result then begin
      Exit(result);
    end;
  tp := __Pptw32_thread_t ( thr.p);
  __ptw32_mcs_lock_acquire (@tp.threadLock, @threadLock);
  s := tp.name; d := name;
  while ( s^ <> #0)  and  (d < &name[len - 1]) do
  begin
    d^ := s^;
    Inc(d);
    Inc(s);
  end;
  d^ := #0;
  __ptw32_mcs_lock_release (@threadLock);
  Result := result;
end;

function pthread_getschedparam( thread : pthread_t; policy : Pinteger; param : Psched_param):integer;
begin
  result := pthread_kill (thread, 0);
  if 0 <> result then begin
      Exit(result);
    end;
  if policy = nil then begin
      Exit(EINVAL);
    end;

  policy^ := Int(SCHED_OTHER);
  param.sched_priority := __Pptw32_thread_t(thread.p).sched_priority;
  Result := 0;
end;

function pthread_getspecific( key : pthread_key_t):Pointer;
var
  ptr          : Pointer;
  lasterror,
  lastWSAerror : integer;
begin
  if key = nil then
      ptr := nil

  else
  begin
    lasterror := GetLastError ();
{$IF defined(RETAIN_WSALASTERROR)}
    lastWSAerror := WSAGetLastError ();
{$IFEND}
    ptr := TlsGetValue (key.key);
    SetLastError (lasterror);
{$IF defined(RETAIN_WSALASTERROR)}
    WSASetLastError (lastWSAerror);
{$IFEND}
  end;
  Result := ptr;
end;

function pthread_getunique_np( thread : pthread_t):uint64;
begin
  Result := __Pptw32_thread_t(thread.p).seqNumber;
end;

function pthread_getw32threadhandle_np( thread : pthread_t): THANDLE;
begin
  Result := __Pptw32_thread_t (thread.p).threadH;
end;


function pthread_getw32threadid_np( thread : pthread_t):DWORD;
begin
  Result := __Pptw32_thread_t (thread.p).thread;
end;

function pthread_join( thread : pthread_t; value_ptr : PPointer):integer;
var

  self : pthread_t;
  tp : __Pptw32_thread_t;
  node : __ptw32_mcs_local_node_t;
begin
  tp := __Pptw32_thread_t( thread.p);
  __ptw32_mcs_lock_acquire(@__ptw32_thread_reuse_lock, @node);
  if (nil = tp) or  (thread.x <> tp.ptHandle.x) then
      result := ESRCH
  else
  if int(PTHREAD_CREATE_DETACHED) = tp.detachState then
     result := EINVAL

  else
     result := 0;

  __ptw32_mcs_lock_release(@node);
  if result = 0 then
  begin

      self := pthread_self();
      if nil = self.p then
         result := ENOENT
      else
      if (pthread_equal (self, thread)) then
        result := EDEADLK

      else
      begin
        result := pthreadCancelableWait (tp.threadH);
        if 0 = result then
        begin
            if value_ptr <> nil then
               value_ptr^ := tp.exitStatus;

            result := pthread_detach (thread);
        end
        else
           result := ESRCH;

      end;
  end;
  Exit((result));
end;

function __ptw32_cancelable_wait( waitHandle : THANDLE; timeout : DWORD):integer;
var
  self      : pthread_t;
  sp        : __Pptw32_thread_t;
  handles   : array[0..1] of THANDLE;
  nHandles,
  status    : DWORD;
  stateLock : __ptw32_mcs_local_node_t;
begin
  nHandles := 1;
  handles[0] := waitHandle;
  self := pthread_self();
  sp := __Pptw32_thread_t ( self.p);
  if sp <> nil then
  begin

      if sp.cancelState = Int(PTHREAD_CANCEL_ENABLE) then
      begin
        handles[1] := sp.cancelEvent;
        if Null <> (handles[1]) then
           Inc(nHandles);

      end;
  end
  else
    handles[1] := null;

  status := WaitForMultipleObjects (nHandles, @handles, __PTW32_FALSE, timeout);
  case status - WAIT_OBJECT_0 of
    0:
      result := 0;
      //break;
    1:
    begin
      ResetEvent (handles[1]);
      if sp <> nil then
      begin
        __ptw32_mcs_lock_acquire (@sp.stateLock, @stateLock);
        if sp.state < PThreadStateCanceling then
        begin
            sp.state := PThreadStateCanceling;
            sp.cancelState := Int(PTHREAD_CANCEL_DISABLE);
            __ptw32_mcs_lock_release (@stateLock);
            __ptw32_throw  (__PTW32_EPS_CANCEL);

        end;
        __ptw32_mcs_lock_release (@stateLock);
      end;

      result := EINVAL;
    end;
    else
    begin
      if status = WAIT_TIMEOUT then
        result := ETIMEDOUT
      else
        result := EINVAL;
    end;

  end;

end;


function pthreadCancelableWait( waitHandle : THANDLE):integer;
begin
  Result := __ptw32_cancelable_wait (waitHandle, INFINITE);
end;


function pthreadCancelableTimedWait( waitHandle : THANDLE; timeout : DWORD):integer;
begin
  Result := (__ptw32_cancelable_wait (waitHandle, timeout));
end;

function pthread_key_create( key : Ppthread_key_t; _destructor : Pdestructor):integer;
var

  newkey : pthread_key_t;
begin
  result := 0;
  newkey := pthread_key_t( calloc (1, sizeof ( newkey^)));
  if newkey = nil then
  begin
    result := ENOMEM;
  end
  else
  begin
    newkey.key := TlsAlloc ();
    if (newkey.key = TLS_OUT_OF_INDEXES) then
    begin
      result := EAGAIN;
      free (newkey);
      newkey := nil;
    end
    else
    if (_destructor <> nil)  then
    begin

      newkey.keyLock := nil;
      newkey._destructor := _destructor;
    end;
  end;
  key^ := newkey;

end;

procedure __ptw32_tkAssocDestroy( assoc : PThreadKeyAssoc);
var
  prev, next : PThreadKeyAssoc;
begin
  if assoc <> nil then
  begin
      prev := assoc.prevKey;
      next := assoc.nextKey;
      if prev <> nil then begin
        prev.nextKey := next;
      end;
      if next <> nil then begin
        next.prevKey := prev;
      end;
      if assoc.thread.keys = assoc then begin

        assoc.thread.keys := next;
      end;
      if assoc.thread.nextAssoc = assoc then begin

        assoc.thread.nextAssoc := next;
      end;

      prev := assoc.prevThread;
      next := assoc.nextThread;
      if prev <> nil then begin
        prev.nextThread := next;
      end;
      if next <> nil then begin
        next.prevThread := prev;
      end;
      if assoc.key.threads = assoc then begin

        assoc.key.threads := next;
      end;
      free (assoc);
  end;
end;

function pthread_key_delete( key : pthread_key_t):integer;
var
  keyLock    : __ptw32_mcs_local_node_t;
  assoc      : PThreadKeyAssoc;
  threadLock : __ptw32_mcs_local_node_t;
  thread: __Pptw32_thread_t;
begin
  result := 0;
  if key <> nil then
  begin
      if (key.threads <> nil)  and  (key._destructor <> nil) then
        begin
          __ptw32_mcs_lock_acquire (@key.keyLock, @keyLock);
          assoc := PThreadKeyAssoc(key.threads);
          while (assoc  <> nil) do
          begin
            thread := assoc.thread;
            if assoc = nil then
                break;

            __ptw32_mcs_lock_acquire (@thread.threadLock, @threadLock);
            __ptw32_tkAssocDestroy (assoc);
            __ptw32_mcs_lock_release (@threadLock);
            assoc := PThreadKeyAssoc(key.threads);
          end;
          __ptw32_mcs_lock_release (@keyLock);
        end;
      TlsFree (key.key);
      if key._destructor <> nil then
      begin

          __ptw32_mcs_lock_acquire (@key.keyLock, @keyLock);
          __ptw32_mcs_lock_release (@keyLock);
      end;
{$IF defined( _DEBUG )}
      memset ((char *) key, 0, sizeof ( *key));
{$IFEND}
      free (key);
  end;

end;

function pthread_kill( thread : pthread_t; sig : integer):integer;
var
  tp: __Pptw32_thread_t;
  node : __ptw32_mcs_local_node_t;
begin
  result := 0;
  if 0 <> sig then
     result := EINVAL

  else
  begin

    __ptw32_mcs_lock_acquire(@__ptw32_thread_reuse_lock, @node);
    tp := __Pptw32_thread_t ( thread.p);
    if (nil = tp) or  (thread.x <> tp.ptHandle.x) or
       (tp.state < PThreadStateRunning) then
      result := ESRCH;

    __ptw32_mcs_lock_release(@node);
  end;
  Exit(result);
end;

function __ptw32_robust_mutex_inherit( mutex : Ppthread_mutex_t):integer;
var
  n: LONG;
  mx : pthread_mutex_t;
  robust : __Pptw32_robust_node_t;
begin
  mx := mutex^;
  robust := mx.robustNode;
  n := LONG(__PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(
             __PTW32_INTERLOCKED_LONGPTR(@robust.stateInconsistent)^,
             __PTW32_INTERLOCKED_LONG(__PTW32_ROBUST_INCONSISTENT),
             __PTW32_INTERLOCKED_LONG(-1 )));
  case n of

      -1:
          result := EOWNERDEAD;
          //break;
      LONG(__PTW32_ROBUST_NOTRECOVERABLE):
          result := ENOTRECOVERABLE;
          //break;
      else
          result := 0;

  end;

end;


procedure __ptw32_robust_mutex_add( mutex : Ppthread_mutex_t; self : pthread_t);
var
  list : __PPptw32_robust_node_t;
  mx : pthread_mutex_t;
  tp : __Pptw32_thread_t;
  robust : __Pptw32_robust_node_t;
begin
  mx := mutex^;
  tp := __Pptw32_thread_t(self.p);
  robust := mx.robustNode;
  list := @tp.robustMxList;
  mx.ownerThread := self;
  if nil = list^ then
  begin
      robust.prev := nil;
      robust.next := nil;
      list^ := robust;
  end
  else
  begin
    robust.prev := nil;
    robust.next := list^;
    list^.prev := robust;
    list^ := robust;
  end;
end;


procedure __ptw32_robust_mutex_remove( mutex : Ppthread_mutex_t; otp : __Pptw32_thread_t);
var
  list : __PPptw32_robust_node_t;
  mx : pthread_mutex_t;
  robust : __Pptw32_robust_node_t;
begin
  mx := mutex^;
  robust := mx.robustNode;
  list := @__Pptw32_thread_t(mx.ownerThread.p).robustMxList;
  mx.ownerThread.p := otp;
  if robust.next <> nil then begin
      robust.next.prev := robust.prev;
    end;
  if robust.prev <> nil then begin
      robust.prev.next := robust.next;
    end;
  if list^ = robust then begin
     list^ := robust.next;
    end;
end;


function pthread_mutex_consistent( mutex : Ppthread_mutex_t):integer;
var
  mx : pthread_mutex_t;

begin
  mx := mutex^;
  result := 0;

  if mx = nil then begin
      Exit(EINVAL);
    end;
  if (mx.kind >= 0) or
     (__PTW32_INTERLOCKED_LONG (__PTW32_ROBUST_INCONSISTENT) <>
                 __PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(
                                                 __PTW32_INTERLOCKED_LONGPTR(@mx.robustNode.stateInconsistent)^,
                                                 __PTW32_INTERLOCKED_LONG(__PTW32_ROBUST_CONSISTENT),
                                                 __PTW32_INTERLOCKED_LONG(__PTW32_ROBUST_INCONSISTENT))) then
    begin
      result := EINVAL;
    end;

end;

function pthread_barrier_init(barrier: Ppthread_barrier_t; const attr: Ppthread_barrierattr_t; count: Cardinal): Integer;
var
  b : pthread_barrier_t;
begin
  if (barrier = nil)  or  (count = 0) then
      Exit(EINVAL);

  b := pthread_barrier_t(calloc (1, sizeof (b^)));
  if nil <> b then
  begin
    if (attr <> nil)  and  (attr^ <> nil) then
       b.pshared := attr^.pshared
    else
       b.pshared :=  Int(PTHREAD_PROCESS_PRIVATE);
    b.nCurrentBarrierHeight := count;
    b.nInitialBarrierHeight := count;
    b.lock := nil;
    if 0 = sem_init(@b.semBarrierBreeched  , b.pshared, 0) then
    begin
      barrier^ := b;
      Exit(0);
    end;
    free (b);
  end;
  Result := ENOMEM;
end;

procedure __ptw32_mcs_flag_set(var flag : THANDLE);
var
  e : THANDLE;
begin

      e := __PTW32_INTERLOCKED_COMPARE_EXCHANGE_SIZE(LONG(flag), -1, 0);
      if (THANDLE(0) <> e)  and  (THANDLE(-1) <> e) then
         SetEvent(e);


end;


procedure __ptw32_mcs_flag_wait(var flag : THANDLE);
var
  e : THANDLE;
begin
  if 0 = __PTW32_INTERLOCKED_EXCHANGE_ADD_SIZE (flag, 0) then
  begin

    e := CreateEvent(nil,  __PTW32_FALSE,  __PTW32_FALSE, nil);
    //add by softwind 2021.12.24
    SetEvent(e);
    if 0 =  __PTW32_INTERLOCKED_COMPARE_EXCHANGE_SIZE(Long(flag), e, 0)  then
       WaitForSingleObject(e, INFINITE);

    CloseHandle(e);
  end;
end;

procedure __ptw32_mcs_lock_release( node : __Pptw32_mcs_local_node_t);
var
  lock : __Pptw32_mcs_lock_t;
  next : __Pptw32_mcs_local_node_t;
  p1: PPointer;
  n: Integer;
begin
  lock := node.lock;
  n :=  __PTW32_INTERLOCKED_EXCHANGE_ADD_SIZE(
                                     __PTW32_INTERLOCKED_SIZEPTR(@node.next)^, 0 );
  next := __Pptw32_mcs_local_node_t(@n);

  if nil = next then
  begin
      p1 := PPointer(lock);
      if node = __Pptw32_mcs_local_node_t (__PTW32_INTERLOCKED_COMPARE_EXCHANGE_PTR (
                                              p1^,//__PTW32_INTERLOCKED_PVOID_PTR(lock)^,
                                              nil,//__PTW32_INTERLOCKED_PVOID(0),
                                              node) ) then
      begin

        exit;
      end;

      __ptw32_mcs_flag_wait(node.nextFlag);

      n := __PTW32_INTERLOCKED_EXCHANGE_ADD_SIZE (
                                           __PTW32_INTERLOCKED_SIZEPTR(node.next)^,
                                            0);
      next := __Pptw32_mcs_local_node_t (@n);
  end
  else
     __ptw32_mcs_flag_wait(node.nextFlag);

  __ptw32_mcs_flag_set(next.readyFlag);
end;

function __ptw32_mcs_lock_try_acquire( lock : __Pptw32_mcs_lock_t; node : __Pptw32_mcs_local_node_t):integer;
var
  p: Pointer;
  vLock: __PTW32_INTERLOCKED_PVOID_PTR;
begin
  node.lock := lock;
  node.nextFlag := 0;
  node.readyFlag := 0;
  node.next := nil;
  vLock := __PTW32_INTERLOCKED_PVOID_PTR(lock);
  p := __PTW32_INTERLOCKED_COMPARE_EXCHANGE_PTR (vLock^,
                                                 __PTW32_INTERLOCKED_PVOID(node),
                                                 __PTW32_INTERLOCKED_PVOID(0)
                                                );
   if __PTW32_INTERLOCKED_PVOID(p) =  __PTW32_INTERLOCKED_PVOID(0) then
      Result := 0
   else
      Result := EBUSY;
end;


function pthread_barrier_destroy(barrier: Ppthread_barrier_t): Integer;
var
  //result : integer;
  b : pthread_barrier_t;
  node : __ptw32_mcs_local_node_t;
begin
  result := 0;
  if (barrier = nil)  or  (barrier^ = pthread_barrier_t(__PTW32_OBJECT_INVALID) ) then
  begin
    Exit(EINVAL);
  end;

  if 0 <> __ptw32_mcs_lock_try_acquire(@barrier^.lock, @node)  then
  begin
    Exit(EBUSY);
  end;

  b := barrier^;
  if b.nCurrentBarrierHeight < b.nInitialBarrierHeight then
  begin
      result := EBUSY;
  end
  else
  begin
      result := sem_destroy (@b.semBarrierBreeched);
      if 0 = result then
      begin
          barrier^ := pthread_barrier_t(__PTW32_OBJECT_INVALID);

          __ptw32_mcs_lock_release(@node);
          free (b);
          Exit(0);
      end
      else
      begin

        sem_init (@(b.semBarrierBreeched), b.pshared, 0);
      end;
      if result <> 0 then
      begin
         result := EBUSY;
      end;
  end;
  __ptw32_mcs_lock_release(@node);
  Result := (result);
end;

function pthread_attr_setstacksize(attr: Ppthread_attr_t; stacksize: NativeUInt): Integer;
begin
{$IF _POSIX_THREAD_ATTR_STACKSIZE <> int64(-1)}
{$IF PTHREAD_STACK_MIN > 0}
  /
  if stacksize < PTHREAD_STACK_MIN then
  begin
      Exit(EINVAL);
  end;
{$IFEND}
  if __ptw32_is_attr (attr)  <> 0  then
    begin
      Exit(EINVAL);
    end;

  attr^.stacksize := stacksize;
  Exit(0);
{$ELSE}
  Exit(ENOSYS);
{$IFEND}
end;

function pthread_attr_setstackaddr(attr: Ppthread_attr_t; stackaddr: Pointer): Integer;
begin
//{$IF _POSIX_THREAD_ATTR_STACKADDR <> int64(-1)}
{$IF _POSIX_THREAD_ATTR_STACKSIZE <> int64(-1)}
  if __ptw32_is_attr (attr) <> 0 then
    begin
      Exit(EINVAL);
    end;
  attr^.stackaddr := stackaddr;
  Exit(0);
{$ELSE}
  Exit(ENOSYS);
{$IFEND}
end;

function pthread_attr_setscope(attr: Ppthread_attr_t ; contentionscope : integer):integer;
begin
{$IF 0<(_POSIX_THREAD_PRIORITY_SCHEDULING)}
  case contentionscope of
    PTHREAD_SCOPE_SYSTEM:
      ( *attr).contentionscope = contentionscope;
      Exit(0);
    PTHREAD_SCOPE_PROCESS:
      Exit(ENOTSUP);
    else
      Exit(EINVAL);
    end;
{$ELSE}
   Exit(ENOSYS);
{$IFEND}
end;

function pthread_attr_setschedpolicy(attr: Ppthread_attr_t; policy: Integer): Integer;
begin
  if __ptw32_is_attr (attr)  <> 0 then
    begin
      Exit(EINVAL);
    end;
  if policy <> Int(SCHED_OTHER) then
  begin
      Exit(ENOTSUP);
    end;
  Result := 0;
end;


function pthread_attr_setschedparam(attr: Ppthread_attr_t; const param: Psched_param): Integer;
var
  priority : integer;
begin
  if (__ptw32_is_attr (attr)  <> 0)  or  (param = nil) then
    begin
      Exit(EINVAL);
    end;
  priority := param.sched_priority;

  if (priority < sched_get_priority_min (Int(SCHED_OTHER)))  or
     ( priority > sched_get_priority_max (Int(SCHED_OTHER))) then
    begin
      Exit(EINVAL);
    end;
  memcpy (@attr^.param, param, sizeof ( param^));
  Result := 0;
end;

{$if defined (__PTW32_COMPATIBILITY_BSD) or defined (__PTW32_COMPATIBILITY_TRU64)}
function pthread_attr_setname_np(var name : byte; arg):integer;
var
  len, result : integer;
  tmpbuf : array[0..(PTHREAD_MAX_NAMELEN_NP)-1] of byte;
begin
  char * newname;
  char * oldname;
  /
  len := snprintf(tmpbuf, PTHREAD_MAX_NAMELEN_NP-1, name, arg);
  tmpbuf[PTHREAD_MAX_NAMELEN_NP-1] := #0;
  if len < 0 then begin
      Exit(EINVAL);
    end;
  newname := _strdup(tmpbuf);
  oldname := ( *attr).thrname;
  ( *attr).thrname = newname;
  if oldname then begin
      free(oldname);
    end;
  Result := 0;
end;
{$ELSE}
function pthread_attr_setname_np(attr: Ppthread_attr_t; const name: PChar): Integer;
var
  newname, oldname: PChar;
begin

  newname := strdup(name);
  oldname := attr^.thrname;
  attr^.thrname := newname;
  if Assigned(oldname) then
  begin
      free(oldname);
    end;
  Result := 0;
end;
{$IFEND}

function pthread_attr_setinheritsched(attr: Ppthread_attr_t; inheritsched: Integer): Integer;
begin
  if __ptw32_is_attr (attr)  <> 0 then
    begin
      Exit(EINVAL);
    end;
  if (Int(PTHREAD_INHERIT_SCHED) <> inheritsched) and
     (Int(PTHREAD_EXPLICIT_SCHED) <> inheritsched) then
  begin
      Exit(EINVAL);
  end;

  attr^.inheritsched := inheritsched;
  Result := 0;
end;


function pthread_attr_setdetachstate(attr: Ppthread_attr_t; detachstate: Integer): Integer;
begin
  if __ptw32_is_attr (attr)  <> 0 then
    begin
      Exit(EINVAL);
    end;
  if (detachstate <> Int(PTHREAD_CREATE_JOINABLE) ) and
     (detachstate <> Int(PTHREAD_CREATE_DETACHED)) then
     begin
      Exit(EINVAL);
    end;
  attr^.detachstate := detachstate;
  Result := 0;
end;

function pthread_attr_setaffinity_np(attr: Ppthread_attr_t; cpusetsize: NativeUInt; const cpuset: Pcpu_set_t): Integer;
begin
  if (__ptw32_is_attr (attr)  <> 0)  or  (cpuset = nil) then
    begin
      Exit(EINVAL);
    end;
  attr^.cpuset := _Psched_cpu_set_vector_(cpuset)._cpuset;
  Result := 0;
end;

procedure CPU_ZERO(setptr: Pcpu_set_t);
begin
  _sched_affinitycpuzero(setptr);
end;

function pthread_attr_init(attr: Ppthread_attr_t):integer;
var
  attr_result : pthread_attr_t;
  cpuset      : cpu_set_t;
begin
  if attr = nil then
  begin

      Exit(EINVAL);
    end;
  attr_result := pthread_attr_t( malloc (sizeof ( attr_result^)));
  if attr_result = nil then
  begin
      Exit(ENOMEM);
  end;
//{$IF int64(0)< _POSIX_THREAD_ATTR_STACKSIZE}
{$IF _POSIX_THREAD_ATTR_STACKSIZE > int64(0)}

  attr_result.stacksize := 0;
{$IFEND}
{$IF 0<(_POSIX_THREAD_ATTR_STACKADDR)}

  attr_result.stackaddr := nil;
{$IFEND}
  attr_result.detachstate := Integer(PTHREAD_CREATE_JOINABLE);
{$IF defined(HAVE_SIGSET_T)}
  memset (&(attr_result.sigmask), 0, sizeof (sigset_t));
{$IFEND}

  attr_result.param.sched_priority := THREAD_PRIORITY_NORMAL;
  attr_result.inheritsched := Int(PTHREAD_EXPLICIT_SCHED);
  attr_result.contentionscope := Int(PTHREAD_SCOPE_SYSTEM);
  CPU_ZERO(@cpuset);
  attr_result.cpuset := _Psched_cpu_set_vector_(@cpuset)._cpuset;
  attr_result.thrname := nil;
  attr_result.valid := __PTW32_ATTR_VALID;
  attr^ := attr_result;
  Result := 0;
end;


function pthread_attr_getstacksize(const attr: Ppthread_attr_t; stacksize: PNativeUInt): Integer;
begin
//{$IF _POSIX_THREAD_ATTR_STACKSIZE <> -1}
{$IF _POSIX_THREAD_ATTR_STACKSIZE <> int64(-1)}
  if __ptw32_is_attr (attr)  <> 0  then
    begin
      Exit(EINVAL);
    end;

  stacksize^ := attr^.stacksize;
  Exit(0);
{$ELSE}
  Exit(ENOSYS);
{$IFEND}
end;


function pthread_attr_getstackaddr(const attr: Ppthread_attr_t; stackaddr: PPointer): Integer;
begin
//{$IF _POSIX_THREAD_ATTR_STACKADDR <> -1}
{$IF _POSIX_THREAD_ATTR_STACKSIZE <> int64(-1)}
  if __ptw32_is_attr (attr) <> 0  then
    begin
      Exit(EINVAL);
    end;
  stackaddr^ := attr^.stackaddr;
  Exit(0);
{$ELSE}
  Exit(ENOSYS);
{$IFEND}
end;

function pthread_attr_getscope(const attr: Ppthread_attr_t; contentionscope: PInteger): Integer;
begin
{$IF defined(_POSIX_THREAD_PRIORITY_SCHEDULING)}
  *contentionscope = ( *attr).contentionscope;
  Exit(0);
{$ELSE}
  Exit(ENOSYS);
{$IFEND}
end;

function pthread_attr_getschedpolicy(const attr: Ppthread_attr_t; policy: PInteger): Integer;
begin
  if (__ptw32_is_attr (attr)  <> 0)  or  (policy = nil) then
    begin
      Exit(EINVAL);
    end;
  policy^ := Integer(SCHED_OTHER);
  Result := 0;
end;


function pthread_attr_getschedparam(const attr: Ppthread_attr_t; param: Psched_param): Integer;
begin
  if (__ptw32_is_attr (attr)  <> 0)  or  (param = nil) then
    begin
      Exit(EINVAL);
    end;
  memcpy (param, @attr^.param, sizeof ( param^));
  Result := 0;
end;


function pthread_attr_getname_np(attr: Ppthread_attr_t; name: PChar; len: Integer): Integer;
begin
{$IF defined(_MSVCRT_)}
  strncpy(name, attr^.thrname, len - 1);
  attr^.thrname[len - 1] := #0;
{$IFEND}
  Result := 0;
end;

function pthread_attr_getinheritsched(const attr: Ppthread_attr_t; inheritsched: PInteger): Integer;
begin
  if (__ptw32_is_attr (attr)  <> 0)  or  (inheritsched = nil) then
    begin
      Exit(EINVAL);
    end;
  inheritsched^ := attr^.inheritsched;
  Result := 0;
end;


function pthread_attr_getdetachstate(const attr: Ppthread_attr_t; detachstate: PInteger): Integer;
begin
  if (__ptw32_is_attr (attr) <> 0)  or  (detachstate = nil)  then
    begin
      Exit(EINVAL);
    end;
  detachstate^ := attr^.detachstate;
  Result := 0;
end;

function pthread_attr_getaffinity_np(const attr: Ppthread_attr_t; cpusetsize: NativeUInt; cpuset: Pcpu_set_t): Integer;
begin
  if (__ptw32_is_attr (attr) <> 0)  or  (cpuset = nil)  then
    begin
      Exit(EINVAL);
    end;
  _Psched_cpu_set_vector_(cpuset)._cpuset := attr^.cpuset;
  Result := 0;
end;


function __ptw32_calloc( n, s : size_t):Pointer;
var
  p : pointer;
  m: UInt32;
begin
  m := n * s;
  p := malloc (m);
  if p = nil then
     Exit(nil);
  memset (p, 0, m);
  Result := p;
end;

function __ptw32_is_attr(const attr: Ppthread_attr_t): integer;
begin

  if (attr = nil)  or
     (attr^ = nil)  or
     ( attr^.valid <>  __PTW32_ATTR_VALID) then
     Result := 1
  else
     Result := 0;
end;

function pthread_attr_destroy(attr: Ppthread_attr_t): Integer;
begin
  if __ptw32_is_attr (attr)  <> 0  then
    begin
      Exit(EINVAL);
    end;

  attr^.valid := 0;
  free ( attr^);
  attr^ := nil;
  Result := 0;
end;

initialization
   __ptw32_selfThreadKey := malloc(SizeOf(pthread_key_t_));
   __ptw32_thread_reuse_lock := malloc(SizeOf(__ptw32_thread_reuse_lock^));
{$POINTERMATH OFF}
end.
