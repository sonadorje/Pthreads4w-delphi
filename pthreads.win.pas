unit pthreads.win;
{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }
{$I config.inc}


{$MINENUMSIZE 4}

interface
{$POINTERMATH ON}
uses
 {$IFDEF FPC}
   sysutils, windows,  jwaiptypes, jwawindows,
 {$else}
   Winapi.Windows,

   System.Classes, System.SysUtils,
   System.Variants, System.Win.Crtl,
 {$endif}    libc.Types;

const
   _JBFP    = 1;
   _JBMOV   = 60;
   _JBOFF   = 4;
   _NSETJMP = 17;
   PTW32_EPS_EXIT  =                (1);
   PTW32_EPS_CANCEL  =              (2);

   CPU_SETSIZE = sizeof(size_t)*8;
   PTW32_ATTR_VALID = ulong( $C4C0FFEE);
   PTW32_OBJECT_INVALID   = nil;
   PTHREAD_CANCELED = Pointer(size_t( -1));



  _POSIX_THREADS = 200809;
  _POSIX_READER_WRITER_LOCKS = 200809;
  _POSIX_SPIN_LOCKS = 200809;
  _POSIX_BARRIERS = 200809;
  _POSIX_THREAD_SAFE_FUNCTIONS = 200809;
  {$IFDEF  FPC}
  _POSIX_THREAD_ATTR_STACKSIZE: Int64  = 200809;
  {$ELSE}
  _POSIX_THREAD_ATTR_STACKSIZE = 20080;
  {$ENDIF}
  _POSIX_ROBUST_MUTEXES = 200809;
  _POSIX_THREAD_ATTR_STACKADDR = -1;
  _POSIX_THREAD_PRIO_INHERIT = -1;
  _POSIX_THREAD_PRIO_PROTECT = -1;
  _POSIX_THREAD_PRIORITY_SCHEDULING = -1;
  _POSIX_THREAD_PROCESS_SHARED = -1;
  _POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4;
  PTHREAD_DESTRUCTOR_ITERATIONS = _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
  _POSIX_THREAD_KEYS_MAX = 128;
  PTHREAD_KEYS_MAX = _POSIX_THREAD_KEYS_MAX;
  PTHREAD_STACK_MIN = 0;
  _POSIX_THREAD_THREADS_MAX = 64;
  PTHREAD_THREADS_MAX = 2019;
  _POSIX_SEM_NSEMS_MAX = 256;
  SEM_NSEMS_MAX = 1024;
  _POSIX_SEM_VALUE_MAX = 32767;
  { Minimum and maximum values a `signed int' can hold.  }
  INT_MAX = 2147483647;
  SEM_VALUE_MAX = INT_MAX;
  PTW32_VERSION_MAJOR = 3;
  PTW32_FALSE = False;
  PTW32_TRUE = True;

  
type
  PVOID = Pointer;
  LPVOID = Pointer;
  wchar_t = System.UCS4Char;
  WCHAR = WideChar;
  DWORD = Cardinal;
  ULONG_PTR = NativeUInt;
  DWORD_PTR = ULONG_PTR;
  THandle = System.THandle;
  PHandle = ^THandle;
  Pwchar_t = System.PUCS4Char;
  PPwchar_t = ^Pwchar_t;
  UTF8Char = AnsiChar;

  PTW32_INTERLOCKED_PVOID_PTR  = ^PVOID;
  PTW32_INTERLOCKED_LONG = Integer;
  {$IFNDEF WIN64}
  PTW32_INTERLOCKED_LONGPTR = PInteger;
  {$ELSE}
  PTW32_INTERLOCKED_LONGPTR = PInt64;
  {$ENDIF}

  {$if defined(_WIN64)}
  #  define  PTW32_INTERLOCKED_SIZE LONGLONG
  #  define  PTW32_INTERLOCKED_SIZEPTR  PTW32_INTERLOCKED_VOLATILE LONGLONG*
  {$else }
     PTW32_INTERLOCKED_SIZE = Integer;//long ;
     PTW32_INTERLOCKED_SIZEPTR  = PInteger;
  {$ENDIF}
  //#define  PTW32_INTERLOCKED_PVOID PVOID
   PTW32_INTERLOCKED_PVOID = PVOID;
  Pptw32_mcs_node_t_ = ^PTW32_mcs_node_t_;
  __PPptw32_mcs_node_t_ = ^Pptw32_mcs_node_t_ ;

  //typedef struct PTW32_mcs_node_t_*    PTW32_mcs_lock_t;
  ptw32_mcs_lock_t =  ^ptw32_mcs_node_t_;
  Pptw32_mcs_lock_t = ^ptw32_mcs_lock_t;

  ptw32_mcs_node_t_ = record

    lock                : Pptw32_mcs_lock_t;
    next                : ptw32_mcs_lock_t;
    readyFlag,
    nextFlag            : THANDLE;
 end;

  ptw32_mcs_local_node_t = ptw32_mcs_node_t_ ;
  Pptw32_mcs_local_node_t = ^ptw32_mcs_local_node_t;


  // Forward declarations
  sched_param = record
    sched_priority: Integer;
  end;

 {$IFNDEF  USE_CJMP}
 jmp_buf = record
    EBX,
    ESI,
    EDI,
    ESP,
    EBP,
    EIP: longword;
  end;
{$ELSE}
  jmp_buf = array[0.._NSETJMP-1] of Integer;
{$ENDIF}

  _sched_cpu_set_vector_ = record
     case integer of
       0: (cpuset : array[0..(CPU_SETSIZE div 8)-1] of byte);
       1: (_cpuset : size_t);
   end;

   PAPCFUNC = procedure(dwParam: DWORD);
   //PAPC_FUNC = ^TAPC_FUNC;
   Tregister_cancellation_func = function (func: PAPCFUNC; handle: THANDLE; p1: DWORD): DWORD;


  _Psched_cpu_set_vector_ = ^_sched_cpu_set_vector_;
  pthread_attr_t_ = record
    valid: ulong;

    stackaddr       : pointer;
    stacksize       : size_t;
    detachstate     : integer;
    param           : sched_param;
    inheritsched,
    contentionscope : integer;
    cpuset          : size_t;
    thrname         : PChar;
    {$if defined(HAVE_SIGSET_T)}
    sigmask         : sigset_t;
    {$ENDIF}
  end;

  PNativeUInt = ^NativeUInt;
 
  Ppthread_key_t_ = Pointer;
  PPpthread_key_t_ = ^Ppthread_key_t_;
  Ppthread_mutex_t_ = Pointer;
  PPpthread_mutex_t_ = ^Ppthread_mutex_t_;

  
  Ppthread_cond_t_ = Pointer;
  PPpthread_cond_t_ = ^Ppthread_cond_t_;
  Ppthread_condattr_t_ = Pointer;
  PPpthread_condattr_t_ = ^Ppthread_condattr_t_;
  Ppthread_rwlock_t_ = Pointer;
  PPpthread_rwlock_t_ = ^Ppthread_rwlock_t_;
  Ppthread_rwlockattr_t_ = Pointer;
  PPpthread_rwlockattr_t_ = ^Ppthread_rwlockattr_t_;
  Ppthread_spinlock_t_ = Pointer;
  PPpthread_spinlock_t_ = ^Ppthread_spinlock_t_;
  Ppthread_barrier_t_ = Pointer;
  PPpthread_barrier_t_ = ^Ppthread_barrier_t_;
  Ppthread_barrierattr_t_ = Pointer;
  PPpthread_barrierattr_t_ = ^Ppthread_barrierattr_t_;
  time_t = {$IFDEF Win32} Integer {$ENDIF}
           {$IFDEF Win64} Int64 {$ENDIF};
  timespec = record
    tv_sec   : time_t;
    tv_nsec  : integer;
  end;
  Ptimespec = ^timespec;
  PPtimespec = ^Ptimespec;

  sem_t_ = record
    value         : integer;
    lock          : PTW32_mcs_lock_t;
    sem           : THANDLE;
    {$if defined(NEED_SEM)}
    leftToUnblock : integer;
    {$ENDIF}
  end;
  //typedef struct sem_t_ * sem_t;
  sem_t = ^sem_t_;
  Psem_t = ^sem_t;
  //PPsem_t_ = ^Psem_t_;
  Psched_param = ^sched_param;

  Ppthread_once_t_ = ^pthread_once_t_;


 
  int64_t = Int64;
  uint64_t = UInt64;
  Puint64_t = ^uint64_t;



  pid_t = Integer;

  _anonymous_type_2 = (
    SCHED_OTHER = 0,
    SCHED_FIFO = 1,
    SCHED_RR = 2,
    SCHED_MIN = 0,
    SCHED_MAX = 2);
  P_anonymous_type_2 = ^_anonymous_type_2;

  

  cpu_set_t = record
    case Integer of
      0: (cpuset: array [0..(CPU_SETSIZE div 8 -1)] of UTF8Char);// = (#0,#0,#0,#0,#0,#0,#0,#0));
      1: (_align: NativeUInt);
  end;
  Pcpu_set_t = ^cpu_set_t;

  pthread_t = record
    p: Pointer;
    x: NativeUInt;
  end;

{$if  PTW32_VERSION_MAJOR > 2}

//#define PTHREAD_ONCE_INIT       { 0,  PTW32_FALSE }
 pthread_once_t_  = record
  lock: Pointer;		(* MCS lock *)
  done: int;    	(* indicates if user function has been executed *)
 end;
{$else}
//#define PTHREAD_ONCE_INIT       {  PTW32_FALSE, 0, 0, 0 }
pthread_once_t_ = record
  done: int;       	(* indicates if user function has been executed *)
  lock: Pointer;		(* MCS lock *)
  reserved1,
  reserved2: int;
end;
{$ENDIF}

  Ppthread_t = ^pthread_t;

  PThreadState = (
  PThreadStateInitial = 0,	(* Thread not running                   *)
  PThreadStateReuse,            (* In reuse pool.                       *)
  PThreadStateRunning,		(* Thread alive & kicking               *)
  PThreadStateSuspended,	(* Thread alive but suspended           *)
  PThreadStateCancelPending,	(* Thread alive but                     *)
                                (* has cancellation pending.            *)
  PThreadStateCanceling,	(* Thread alive but is                  *)
                                (* in the process of terminating        *)
                                (* due to a cancellation request        *)
  PThreadStateExiting,		(* Thread alive but exiting             *)
                                (* due to an exception                  *)
  PThreadStateLast );

  Pptw32_robust_node_t = ^PTW32_robust_node_t;
  __PPptw32_robust_node_t = ^Pptw32_robust_node_t;

  Pptw32_thread_t = ^PTW32_thread_t;
  PTW32_thread_t_ = record
      seqNumber      : uint64;
      threadHandle   : THANDLE;
      ptHandle       : pthread_t;
      prevReuse      : Pptw32_thread_t;
      {$IFnDEF FPC}[volatile]{$ENDIF} state          : PThreadState;
      threadLock,
      stateLock      : PTW32_mcs_lock_t;
      cancelEvent    : THANDLE;
      exitStatus,
      parms,
      keys,
      nextAssoc      : pointer;
      {$if defined(PTW32_CLEANUP_C)}
      start_mark     : jmp_buf;
      {$ENDIF}
      {$if defined(HAVE_SIGSET_T)}
      sigmask        : sigset_t;
      {$ENDIF}
      robustMxListLock : PTW32_mcs_lock_t;
      robustMxList     : Pptw32_robust_node_t;
      ptErrno,
      detachState,
      sched_priority,
      cancelState,
      cancelType,
      implicit     : integer;
      thread_id      : DWORD;
      {$if defined(HAVE_CPU_AFFINITY)}
      cpuset         : size_t;
      {$ENDIF}
      name           : Pchar;
      {$if defined(_UWIN)}
      dummy          : array[0..4] of DWORD;
      {$ENDIF}
      align          : size_t;

  end;
  PTW32_thread_t = PTW32_thread_t_;

  //typedef struct pthread_attr_t_ * pthread_attr_t;
  pthread_attr_t = ^pthread_attr_t_;
  Ppthread_attr_t = ^pthread_attr_t;
  //typedef struct pthread_once_t_ pthread_once_t;
  pthread_once_t = pthread_once_t_;
  Ppthread_once_t = ^pthread_once_t;

  Tdestructor_func = procedure(p: Pointer);

  pthread_key_t_ = record
    key            : DWORD;
    _destructor    : Tdestructor_func;
    keyLock        : PTW32_mcs_lock_t;
    threads        : pointer;
  end;
  //typedef struct pthread_key_t_ * pthread_key_t;
  pthread_key_t = ^pthread_key_t_;
  Ppthread_key_t = ^pthread_key_t;

  PTW32_robust_state_t_ = (

   PTW32_ROBUST_CONSISTENT,
   PTW32_ROBUST_INCONSISTENT,
   PTW32_ROBUST_NOTRECOVERABLE
 );
  PTW32_robust_state_t = PTW32_robust_state_t_;

  pthread_mutex_t_ = record
    lock_idx         : LONG;
    recursive_count,
    kind             : integer;
    ownerThread      : pthread_t;
    event            : THANDLE;
    robustNode       : Pptw32_robust_node_t;
  end;

  pthread_mutex_t = ^pthread_mutex_t_;
  Ppthread_mutex_t = ^pthread_mutex_t;

  PTW32_robust_node_t_ = record

    mx                     : pthread_mutex_t;
    stateInconsistent      : PTW32_robust_state_t;
    prev,
    next                   : Pptw32_robust_node_t;
  end;
  PTW32_robust_node_t = PTW32_robust_node_t_;

  pthread_mutexattr_t_ = record

    pshared,
    kind,
    robustness           : integer;
  end;

  pthread_mutexattr_t = ^pthread_mutexattr_t_;
  Ppthread_mutexattr_t = ^pthread_mutexattr_t;

  pthread_cond_t = ^pthread_cond_t_;
  pthread_cond_t_ = record
    nWaitersBlocked,
    nWaitersGone,
    nWaitersToUnblock : long;
    semBlockQueue,
    semBlockLock      : sem_t;
    mtxUnblockLock    : pthread_mutex_t;
    next,
    prev              : pthread_cond_t;
  end;


  Ppthread_cond_t = ^pthread_cond_t;
  pthread_condattr_t_ = record
    pshared             : integer;
  end;
  pthread_condattr_t = ^pthread_condattr_t_;
  Ppthread_condattr_t = ^pthread_condattr_t;

  pthread_rwlockattr_t_ = record

    pshared: int ;
  end;
  pthread_rwlockattr_t = ^pthread_rwlockattr_t_ ;
  Ppthread_rwlockattr_t = ^pthread_rwlockattr_t;

  _U = record
    case integer of

       0: (cpus  : integer);
       1: (mutex : pthread_mutex_t);
   end;
  pthread_spinlock_t_ = record

    interlock           : long;
    u: _U
  end;

  pthread_spinlock_t = ^pthread_spinlock_t_ ;
  Ppthread_spinlock_t = ^pthread_spinlock_t;

  pthread_barrier_t_ = record
    nCurrentBarrierHeight,
    nInitialBarrierHeight : uint32;
    pshared               : integer;
    semBarrierBreeched    : sem_t;
    lock                  : PTW32_mcs_lock_t;
    proxynode             : PTW32_mcs_local_node_t;
  end;
  //typedef struct pthread_barrier_t_ * pthread_barrier_t;
  pthread_barrier_t = ^pthread_barrier_t_;
  Ppthread_barrier_t = ^pthread_barrier_t;

  pthread_barrierattr_t_ = record

    pshared: int;
  end;
  pthread_barrierattr_t = ^pthread_barrierattr_t_;
  Ppthread_barrierattr_t = ^pthread_barrierattr_t;

const
    PTHREAD_CREATE_JOINABLE = 0;
    PTHREAD_CREATE_DETACHED = 1;
    PTHREAD_INHERIT_SCHED = 0;
    PTHREAD_EXPLICIT_SCHED = 1;
    PTHREAD_SCOPE_PROCESS = 0;
    PTHREAD_SCOPE_SYSTEM = 1;
    PTHREAD_CANCEL_ENABLE = 0;
    PTHREAD_CANCEL_DISABLE = 1;
    PTHREAD_CANCEL_ASYNCHRONOUS = 0;
    PTHREAD_CANCEL_DEFERRED = 1;
    PTHREAD_PROCESS_PRIVATE = 0;
    PTHREAD_PROCESS_SHARED = 1;
    PTHREAD_MUTEX_STALLED = 0;
    PTHREAD_MUTEX_ROBUST = 1;
    PTHREAD_BARRIER_SERIAL_THREAD = -1;

type
  _anonymous_type_4 = (
    PTHREAD_MUTEX_FAST_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_TIMED_NP = PTHREAD_MUTEX_FAST_NP,
    PTHREAD_MUTEX_ADAPTIVE_NP = PTHREAD_MUTEX_FAST_NP,
    (* For compatibility with POSIX *)
    PTHREAD_MUTEX_NORMAL = 0,//PTHREAD_MUTEX_FAST_NP,
    PTHREAD_MUTEX_RECURSIVE = 1,//PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK = 2,//PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_DEFAULT = 0) ;//PTHREAD_MUTEX_NORMAL);


  Tcleanup_callback_func = procedure(arg: Pointer);
  //Pcleanup_callback_func = ^Tcleanup_callback_func;
  TStartFunc = function(arg: Pointer): Pointer;
  Tbeginthreadex_proc_type = function(arg: Pointer): UInt32;
  Pbeginthreadex_proc_type = ^Tbeginthreadex_proc_type;

  Pptw32_cleanup_t = ^ptw32_cleanup_t;
  ptw32_cleanup_t = record
    routine: Tcleanup_callback_func;
    arg: Pointer;
    prev: Pptw32_cleanup_t;
  end;

  PTW32_features_t = (
    PTW32_SYSTEM_INTERLOCKED_COMPARE_EXCHANGE = $0001,
    PTW32_ALERTABLE_ASYNC_CANCEL = $0002);
  PPTW32_features = ^PTW32_features_t;

   pthread_rwlock_t_ = record


    mtxExclusiveAccess,
    mtxSharedAccessCompleted    : pthread_mutex_t;
    cndSharedAccessCompleted    : pthread_cond_t;
    nSharedAccessCount,
    nExclusiveAccessCount,
    nCompletedSharedAccessCount,
    nMagic                      : integer;
  end;
  pthread_rwlock_t = ^pthread_rwlock_t_;
  Ppthread_rwlock_t = ^pthread_rwlock_t;

  PTW32_cond_wait_cleanup_args_t = record
     mutexPtr  : Ppthread_mutex_t;
    cv        : pthread_cond_t;
    resultPtr : Pinteger;
  end;
  Pptw32_cond_wait_cleanup_args_t = ^PTW32_cond_wait_cleanup_args_t;

  PThreadKeyAssoc = ^ThreadKeyAssoc;
  ThreadKeyAssoc = record

    thread         : Pptw32_thread_t;
    key            : pthread_key_t;
    nextKey,
    nextThread,
    prevKey,
    prevThread     : PThreadKeyAssoc;
  end;

  old_mutex_t_ = record
    mutex : THANDLE;
    cs : TRTLCriticalSection;
  end;
  //typedef struct old_mutex_t_ * old_mutex_t;
  old_mutex_t = ^old_mutex_t_;
  Pold_mutex_t = ^old_mutex_t;

  old_mutexattr_t_ = record
    pshared: int;
  end;
  old_mutexattr_t = ^old_mutexattr_t_ ;
  Pold_mutexattr_t = ^old_mutexattr_t;

  ThreadParms = record

    tid         : pthread_t;
    start       : TStartFunc;
    arg         : pointer;
  end;
  PThreadParms = ^ThreadParms;

  sem_timedwait_cleanup_args_t = record

    sem       : sem_t;
    resultPtr : Pinteger;
  end;

  Psem_timedwait_cleanup_args_t = ^sem_timedwait_cleanup_args_t;
  Ttry_enter_critical_section_func= function(cs: PRTLCRITICALSECTION): BOOL;

  Tcond_wait_cleanup_func = procedure (args: Pointer);
  HINSTANCE = THandle;              { HINSTANCE from widnef.h }
  Tqueue_user_apc_ex_init_func = function(): BOOL;

  Tqueue_user_apc_ex_fini_func = function(): BOOL;

  PTW32_terminate_handler_func = procedure();


  Tpthread_once_init_routine_func = procedure();

  Tpthread_key_create_destructor_func = procedure(p1: Pointer);
{$IFnDEF FPC}
function InterlockedIncrement64(var Addend: Int64): Int64; stdcall; inline;
{$EXTERNALSYM InterlockedIncrement64}

function InterlockedDecrement64(var Addend: Int64): Int64; stdcall; inline;
{$EXTERNALSYM InterlockedDecrement64}
{$ENDIF}

{$IFDEF FPC}
function memset( dst : Pointer; c : integer; n : size_t):Pointer;
{$ENDIF}

{$IF defined(FPC) or not defined(WIN64)}
function  PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(var Destination: LONG; Exchange: LONG; Comparand: LONG): LONG;
{$else}
function  PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG( Destination: Int64; Exchange: int64; Comparand: int64): int64;
{$ENDIF}

{$IFDEF FPC}
function PTW32_INTERLOCKED_EXCHANGE_LONG(var Target: LONG; Value: LONG): LONG;
{$ELSE}
function PTW32_INTERLOCKED_EXCHANGE_LONG(var Target: Integer; Value: Integer): LONG;
{$ENDIF}


{$IFDEF FPC}
function  PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(var Addend: LONG; Value: LONG): LONG;
{$ELSE}
function  PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(var Addend: Integer; Value: Integer): Integer;
{$ENDIF}


{$IF DEFINED(FPC) or not defined(WIN64)}
function  PTW32_INTERLOCKED_INCREMENT_LONG(var Addend: LONG): LONG;
{$ELSE}
function  PTW32_INTERLOCKED_INCREMENT_LONG(var Addend: Int64): Int64;
{$ENDIF}


{$IF DEFINED(FPC) or not defined(WIN64)}
function  PTW32_INTERLOCKED_DECREMENT_LONG(var Addend: LONG): LONG;
{$ELSE}
function  PTW32_INTERLOCKED_DECREMENT_LONG(var Addend: Int64): Int64;
{$ENDIF}

function  PTW32_INTERLOCKED_COMPARE_EXCHANGE_PTR(var Destination: Pointer; Exchange: Pointer; Comparand: Pointer): Pointer;


// lazarus 下 "var Target" 编译通过，delphi下报E20033错误
function  PTW32_INTERLOCKED_EXCHANGE_PTR(var Target: Pointer; Value: Pointer): Pointer;



{$IF Defined(FPC) or defined(WIN32)}
function PTW32_INTERLOCKED_COMPARE_EXCHANGE_SIZE(var p: LONG; v: LONG; c: LONG): LONG;
{$ELSE}
function PTW32_INTERLOCKED_COMPARE_EXCHANGE_SIZE(var p: int64; v: int64; c: int64): int64;
{$ENDIF}


{$IFDEF FPC}
function  PTW32_INTERLOCKED_EXCHANGE_SIZE(var p: LONG; v: LONG): LONG;
{$ELSE}
function  PTW32_INTERLOCKED_EXCHANGE_SIZE(var p: integer; v: integer): integer;
{$ENDIF}


{$IFDEF FPC}
function  PTW32_INTERLOCKED_EXCHANGE_ADD_SIZE(p: LONG; v: LONG): LONG;
{$ELSE}
function  PTW32_INTERLOCKED_EXCHANGE_ADD_SIZE(p: integer; v: Integer): LONG;
{$ENDIF}


{$IF DEFINED(FPC) or not defined(WIN64)}
function  PTW32_INTERLOCKED_INCREMENT_SIZE(p: Integer): Integer;
{$ELSE}
function  PTW32_INTERLOCKED_INCREMENT_SIZE(p: Int64): Int64;
{$ENDIF}


{$IF DEFINED(FPC) or not defined(WIN64)}
function  PTW32_INTERLOCKED_DECREMENT_SIZE(p: Integer): Integer;
{$ELSE}
function  PTW32_INTERLOCKED_DECREMENT_SIZE(p: Int64): Int64;
{$ENDIF}




const
    OLD_WIN32CS = 0;
    OLD_WIN32MUTEX  =1;
    PTHREAD_COND_INITIALIZER = pthread_cond_t(size_t(-1));
    PTHREAD_MUTEX_INITIALIZER = pthread_mutex_t(size_t( -1));
    PTHREAD_RECURSIVE_MUTEX_INITIALIZER = pthread_mutex_t(size_t( -2));
    PTW32_THREAD_REUSE_EMPTY = Pptw32_thread_t(size_t( 1));
    PTHREAD_RWLOCK_INITIALIZER = pthread_rwlock_t(size_t( -1));
    PTW32_RWLOCK_MAGIC = $facade2;
    PTHREAD_SPINLOCK_INITIALIZER = pthread_spinlock_t(size_t( -1));
    PTW32_OBJECT_AUTO_INIT = Pointer(size_t( -1));
    PTHREAD_ERRORCHECK_MUTEX_INITIALIZER = pthread_mutex_t(size_t( -3));
    NANOSEC_PER_SEC      : int64 = 1000000000;
    NANOSEC_PER_MILLISEC : int64 = 1000000;
    MILLISEC_PER_SEC     : int64 = 1000 ;
    PTW32_SPIN_INVALID     = (0);
    PTW32_SPIN_UNLOCKED    = (1);
    PTW32_SPIN_LOCKED      = (2);
    PTW32_SPIN_USE_MUTEX   = (3);
    SEM_FAILED  = Psem_t (-1);
    (* time between jan 1, 1601 and jan 1, 1970 in units of 100 nanoseconds  *)
 PTW32_TIMESPEC_TO_FILETIME_OFFSET: uint64_t =
	         uint64_t( 27111902 shl 32) + uint64_t( 3577643008);
var

   g_ptw32_selfThreadKey : pthread_key_t = nil;
   g_ptw32_cleanupKey: pthread_key_t = nil;
   g_ptw32_cond_list_lock : ptw32_mcs_lock_t = nil;
   g_ptw32_cond_list_head: pthread_cond_t = nil;
   g_ptw32_cond_list_tail: pthread_cond_t  = nil;
   g_ptw32_cond_test_init_lock: ptw32_mcs_lock_t  = nil;

   g_ptw32_thread_reuse_lock :ptw32_mcs_lock_t  = nil;
   g_ptw32_threadReuseTop: Pptw32_thread_t = ptw32_THREAD_REUSE_EMPTY;
   g_ptw32_threadReuseBottom : Pptw32_thread_t = ptw32_THREAD_REUSE_EMPTY;
   g_ptw32_concurrency: int = 0;
   g_ptw32_mutex_test_init_lock: ptw32_mcs_lock_t = nil;
   g_ptw32_rwlock_test_init_lock: ptw32_mcs_lock_t = nil;
   g_ptw32_recursive_mutexattr_s: pthread_mutexattr_t_ =
            (pshared:Int(PTHREAD_PROCESS_PRIVATE); kind:Int(PTHREAD_MUTEX_RECURSIVE); robustness:Int(PTHREAD_MUTEX_STALLED));
   g_ptw32_errorcheck_mutexattr_s: pthread_mutexattr_t_ =
            (pshared:Int(PTHREAD_PROCESS_PRIVATE); kind:Int(PTHREAD_MUTEX_RECURSIVE); robustness:Int(PTHREAD_MUTEX_STALLED));
   g_ptw32_recursive_mutexattr: pthread_mutexattr_t  = @g_ptw32_recursive_mutexattr_s;
   g_ptw32_errorcheck_mutexattr: pthread_mutexattr_t = @g_ptw32_errorcheck_mutexattr_s;
   g_ptw32_threadSeqNumber: uint64  = 0;
   g_ptw32_spinlock_test_init_lock: ptw32_mcs_lock_t  = nil;
   g_ptw32_processInitialized: Boolean = ptw32_FALSE;
   g_ptw32_features: int = 0;
   g_ptw32_register_cancellation :Tregister_cancellation_func = nil;
   g_ptw32_try_enter_critical_section: Ttry_enter_critical_section_func = nil;
  // Handle to quserex.dll
   g_ptw32_h_quserex, g_ptw32_h_kernel32: HINSTANCE;
   old_mutex_use:int = OLD_WIN32CS;

implementation


{$IF defined(FPC) or not defined(WIN64)}
function  PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(var Destination: LONG; Exchange: LONG; Comparand: LONG): LONG;
{$else}
function  PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG( Destination: Int64; Exchange: int64; Comparand: int64): int64;
{$ENDIF}

begin
   {$IFNDEF WIN64}
    Result := InterlockedCompareExchange(Destination, Exchange, Comparand);
   {$ELSE}
    Result := InterlockedCompareExchange64(Destination, Exchange, Comparand);
   {$ENDIF}
end;

{$IFDEF FPC}
function PTW32_INTERLOCKED_EXCHANGE_LONG(var Target: LONG; Value: LONG): LONG;
{$ELSE}
function PTW32_INTERLOCKED_EXCHANGE_LONG(var Target: Integer; Value: Integer): LONG;
{$ENDIF}
begin
   Result := InterlockedExchange(Target, Value);

end;

{$IFDEF FPC}
function  PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(var Addend: LONG; Value: LONG): LONG;
{$ELSE}
function  PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(var Addend: Integer; Value: Integer): Integer;
{$ENDIF}
begin
   Result := InterlockedExchangeAdd(Addend, Value);
end;

{$IF DEFINED(FPC) or not defined(WIN64)}
function  PTW32_INTERLOCKED_INCREMENT_LONG(var Addend: LONG): LONG;
{$ELSE}
function  PTW32_INTERLOCKED_INCREMENT_LONG(var Addend: Int64): Int64;
{$ENDIF}
begin
   {$IFNDEF WIN64}
   Result := InterlockedIncrement(Addend);
   {$ELSE}
   Result := InterlockedIncrement64(Addend);
   {$ENDIF}
end;

{$IF DEFINED(FPC) or not defined(WIN64)}
function  PTW32_INTERLOCKED_DECREMENT_LONG(var Addend: LONG): LONG;
{$ELSE}
function  PTW32_INTERLOCKED_DECREMENT_LONG(var Addend: Int64): Int64;
{$ENDIF}
begin
  {$IFNDEF WIN64}
   Result := InterlockedDecrement(Addend);
  {$ELSE}
   Result := InterlockedDecrement64(Addend);
  {$ENDIF}
end;

function  PTW32_INTERLOCKED_COMPARE_EXCHANGE_PTR(var Destination: Pointer; Exchange: Pointer; Comparand: Pointer): Pointer;
begin
   RESULT := InterlockedCompareExchangePointer(Destination, Exchange, Comparand);
end;

// lazarus 下 "var Target" 编译通过，delphi下报E20033错误
function  PTW32_INTERLOCKED_EXCHANGE_PTR(var Target: Pointer; Value: Pointer): Pointer;
begin
   RESULT := InterlockedExchangePointer(Target, Value);
end;


{$IF Defined(FPC) or defined(WIN32)}
function PTW32_INTERLOCKED_COMPARE_EXCHANGE_SIZE(var p: LONG; v: LONG; c: LONG): LONG;
{$ELSE}
function PTW32_INTERLOCKED_COMPARE_EXCHANGE_SIZE(var p: int64; v: int64; c: int64): int64;
{$ENDIF}
begin
   Result := PTW32_INTERLOCKED_COMPARE_EXCHANGE_LONG(p,v,c);
end;

{$IFDEF FPC}
function  PTW32_INTERLOCKED_EXCHANGE_SIZE(var p: LONG; v: LONG): LONG;
{$ELSE}
function  PTW32_INTERLOCKED_EXCHANGE_SIZE(var p: integer; v: integer): integer;
{$ENDIF}
begin
   Result := PTW32_INTERLOCKED_EXCHANGE_LONG(p,v);
end;

{$IFDEF FPC}
function  PTW32_INTERLOCKED_EXCHANGE_ADD_SIZE(p: LONG; v: LONG): LONG;
{$ELSE}
function  PTW32_INTERLOCKED_EXCHANGE_ADD_SIZE(p: integer; v: Integer): LONG;
{$ENDIF}
begin
   Result := PTW32_INTERLOCKED_EXCHANGE_ADD_LONG(p, v)   ;
end;

{$IF DEFINED(FPC) or not defined(WIN64)}
function  PTW32_INTERLOCKED_INCREMENT_SIZE(p: Integer): Integer;
{$ELSE}
function  PTW32_INTERLOCKED_INCREMENT_SIZE(p: Int64): Int64;
{$ENDIF}
begin
   Result :=  PTW32_INTERLOCKED_INCREMENT_LONG(p);
end;

{$IF DEFINED(FPC) or not defined(WIN64)}
function  PTW32_INTERLOCKED_DECREMENT_SIZE(p: Integer): Integer;
{$ELSE}
function  PTW32_INTERLOCKED_DECREMENT_SIZE(p: Int64): Int64;
{$ENDIF}
begin
   Result :=  PTW32_INTERLOCKED_DECREMENT_LONG(p);
end;

{$IF not defined(FPC)}
function InterlockedIncrement64;
begin
  Result := AtomicIncrement(Addend);
end;

function InterlockedDecrement64;
begin
  Result := AtomicDecrement(Addend);
end;
{$ENDIF}


{$IFDEF FPC}
//function memset(s: pointer; c: longint; n: size_t): pointer; cdecl; external 'msvcrt' name 'memset';
//https://android.googlesource.com/platform/bionic/+/ics-mr0/libc/string/memset.c
function memset( dst : Pointer; c : integer; n : size_t):Pointer;
var
  q, &end : PChar;
begin
    q := dst;
    &end := q + n;
    while True do
    begin
        if q >= &end then
           break;
        q^ := char(c);
        Inc (q);
        if q >= &end then
           break;
        q^ := char(c);
        Inc (q);
        if q >= &end then
           break;
        q^ := char(c);
        Inc (q);
        if q >= &end then
           break;
        q^ := char(c);
        Inc (q);
    end;
  Result := dst;
end;
{$ENDIF}

procedure dummy( a, b, c, d, e, f, g, h, i, j : integer);
begin
  { threaten to use arguments }
end;



{$POINTERMATH OFF}
end.
